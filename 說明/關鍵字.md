# XS 關鍵字參考

## 流程控制

### [XOR](https://xshelp.xq.com.tw/XSHelp/api?a=XOR&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

XOR 運算式是用來計算兩個邏輯數值的差集。運算方式如下：

- `True XOR True` 傳回 False
- `True XOR False` 傳回 True
- `False XOR True` 傳回 True
- `False XOR False` 傳回 False

---

### [Or](https://xshelp.xq.com.tw/XSHelp/api?a=Or&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

OR 語法用來檢查運算式是否有任一個成立。

**範例:**

```xs
If Close >= Close[1] Or Close >= Close[2] Then ret = 1;
```

在上述範例內如果 Close 欄位 >= 前期值 或是 Close 欄位 >= 前兩期值的話，則 ret 會被設定成 1。

請參考 AND 語法。

---

### [And](https://xshelp.xq.com.tw/XSHelp/api?a=And&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

AND 語法用來檢查運算式是否同時成立。

**範例:**

```xs
If Close >= Close[1] And Volume >= Volume[1] Then ret = 1;
```

在上述範例內如果 close 欄位 >= 前期值 而且同時 volume 欄位 >= 前期值的話，則 ret 會被設定成 1。

請參考 OR 語法。

---

### [Not](https://xshelp.xq.com.tw/XSHelp/api?a=Not&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

NOT 語法回傳運算式的相反值。

**範例 1:**

```xs
If Close > Close[1] Then Ret = 1;
```

這個例子會在 Close 值大於 Close 的前期值時設定 Ret 為 1。

**範例 2:**

如果使用者希望的是在 Close 值 **不是** 大於 Close 的前期值時才設定 Ret 為 1 的話，則可以寫成:

```xs
If Not (Close > Close[1]) Then Ret = 1;
```

上述的範例會在 Close 值不是大於 Close 的前期值時設定 Ret 為 1。

---

### [Cross Above / Cross Below](https://xshelp.xq.com.tw/XSHelp/api?a=Cross&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Cross 相關的語法共有兩種：

- **Cross Above** 或是 **Cross Over** 是用來檢查目前的欄位數值是否向上穿越某個欄位的前期數值。
- **Cross Below** 或是 **Cross Under** 則是用來檢查目前的欄位數值是否向下跌破某個欄位的前期數值。

**範例 1 - 向上穿越均線:**

```xs
If Close Cross Above Average(Close, 5) Then ret = 1;
```

當這一期的 Close 欄位大於等於近 5 期的平均值，且前一期的 Close 欄位小於前一期的近 5 期的平均值的話，則 ret 會被設定成 1。

**範例 2 - 向下跌破均線:**

```xs
If Close Cross Below Average(Close, 5) Then ret = 1;
```

如果這一期的 Close 欄位小於等於近 5 期的平均值，且前一期的 Close 欄位大於前一期的近 5 期的平均值的話，則 ret 會被設定成 1。

> Cross 也可以寫成 Crosses。

---

### [Begin / End](https://xshelp.xq.com.tw/XSHelp/article?a=Begin_End)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Begin / End 語法用在 If, While, For 等控制指令內。當需要輸入超過一行的程式碼時，就必須使用 Begin/End 來把程式碼包圍起來。

**範例 1 - 單行指令:**

```xs
If Close >= Close[1] Then ret = 1;  // 計算漲跌
```

上述範例內當 `Close >= Close[1]` 時因為只需要執行一行指令，所以可以把指令直接寫出來。

**範例 2 - 多行指令:**

由於當 `Close >= Close[1]` 時我們希望要執行兩個指令，所以透過 Begin/End 把這兩個指令包圍起來：

```xs
If Close >= Close[1] Then
Begin
   Value1 = Close - Close[1];  // 計算漲跌
   Value2 = Value1 / Close[1]; // 計算漲跌幅
End;
```

---

### [Ret](https://xshelp.xq.com.tw/XSHelp/article?a=Ret)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Ret 是一個系統的內建變數，他的數值會決定警示腳本以及選股腳本執行結果。

當警示腳本以及選股腳本在每根 bar 重新執行時，Ret 的數值會被設定為 0。當這根 bar 結束完成時如果 Ret 的數值不是 0 的話，則會產生觸發訊號（警示腳本），或是選取這檔商品（選股腳本）。

**範例:**

以下是一個範例，在收盤價大於五日平均值時把 Ret 的數值設為 1，用來觸發警示或是選取這個商品：

```xs
If Close > Average(Close, 5) Then Ret = 1;
```

---

### [Return](https://xshelp.xq.com.tw/XSHelp/api?a=Return&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Return 指令用來中斷正在執行的腳本。當程式遇到這個指令時，執行將會中斷。

**範例:**

```xs
If CurrentTime < 123000 Then Return;

If Close > Close[1] and Close = High Then Ret = 1;
```

上述範例利用 CurrentTime 來判斷執行時間，如果是在 12:30 之前的話則不做任何動作（腳本直接中斷，等待下一根 bar）。在 12:30 過後如果收盤價創當日新高的話則觸發。

---

### [Break](https://xshelp.xq.com.tw/XSHelp/api?a=Break&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Break 指令的用處是控制迴圈執行時跳出迴圈的時機點，一般是用在 For 迴圈或是 While 迴圈內。

**範例:**

以下是 For 迴圈的範例:

```xs
i = 0;
For i = 0 to 10
Begin
	If Close[i] < 20 Then Break;
End;
```

一般而言上面的迴圈會執行 11 次（從 I = 0 到 10）。可是在執行過程內，如果某一期的 Close 欄位值比 20 小的話，就會馬上跳出 For 迴圈。

---

### [Repeat / Until](https://xshelp.xq.com.tw/XSHelp/api?a=Repeat&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Repeat/Until 的語法是用來定義一段迴圈的執行邏輯。

**語法:**

```xs
Repeat
  執行的指令;
Until 判斷式;
```

程式會不斷的執行 Repeat 之後的指令，一直到 Until 後續的判斷式變成 True 值時才會離開迴圈。

如果迴圈內需要執行的指令超過一個的話，則可以使用 Begin/End 來包圍:

```xs
Repeat
  Begin
    執行的指令1;
    執行的指令2;
  End;
Until 判斷式;
```

**範例:**

```xs
SumValue = 0;
Repeat
  Begin
    SumValue = SumValue + Close[i];
    i = i + 1;
  End;
Until i = 4;
AvgValue = SumValue / 5;
```

上述範例內 Repeat 的迴圈會一直執行，每次執行時 SumValue 會累加前幾期的 Close 數值，同時變數 i 會每次加 1。這個迴圈會一直跑到 i = 4 的時候才會離開。以這個範例而言，SumValue 的數值會變成是最近 5 期收盤價的加總，最後算出 AvgValue 為最近 5 期的平均收盤價。

系統內還提供不同的迴圈控制方式，請參考 While 以及 For。

---

### [While](https://xshelp.xq.com.tw/XSHelp/api?a=While&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

While 語法是用來定義一段迴圈的執行邏輯。

**語法:**

```xs
While 判斷式
  執行的指令;
```

當判斷式成立時，While 迴圈會重複的執行，一直到判斷式回傳 False 為止。

如果在迴圈內需要執行多個指令的話，則可以使用 Begin/End 的方式來包圍：

```xs
While 判斷式
Begin
  執行的指令1;
  執行的指令2;
End;
```

**範例:**

```xs
SumValue = 0;
While i < 5
  Begin
    SumValue = SumValue + Close[i];
    i = i + 1;
  End;
AvgValue = SumValue / 5;
```

上述範例內 While 的迴圈會一直執行，直到 i 的數值 >= 5 時才會停止。每次執行時 SumValue 會累加前幾期的 Close 數值，同時變數 i 會每次加 1。以這個範例而言，SumValue 的數值會變成是最近 5 期收盤價的加總，最後算出 AvgValue 為最近 5 期的平均收盤價。

系統內還提供不同的迴圈控制方式，請參考 Repeat/Until 以及 For。

---

### [For To / DownTo](https://xshelp.xq.com.tw/XSHelp/api?a=For&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

For 語法是用來定義一段迴圈的執行邏輯。

For 迴圈語法內必須使用一個變數，指定這個變數的初始值跟結束值，同時指定這個迴圈內要執行的指令：

**語法:**

```xs
For 變數 = 初始值 to 結束值
  執行的指令;
```

如果要執行的指定超過一行的話則使用 Begin/End 語法來包裝需要執行的指定：

```xs
For 變數 = 初始值 to 結束值
Begin
  執行的指令1;
  執行的指令2;
End;
```

迴圈內的指令總共會被執行 **(結束值 - 初始值 + 1) 次**，在期間每次執行時，變數的值會從初始值一一遞增到結束值為止。

**範例 1 - For To:**

```xs
SumValue = 0;
For i = 0 to 4
Begin
	SumValue = SumValue + Close[i];
End;
AvgValue = SumValue / 5;
```

上述的範例是一個累加的用法，透過 For 迴圈總共執行了 5 次（4 - 0 + 1），第一次執行時 i = 0（初始值），第二次執行時 i = 1（遞增），最後一次執行時 i = 4（結束值）。所以執行完 For 迴圈後 SumValue 的數值是最近 5 期 Close 欄位的累加值，把 SumValue 的值除以 5 之後就可以得到 Close 值的平均數值。

**範例 2 - DownTo:**

如果迴圈的控制方式希望是從初始值一直減少直到結束值為止的話，則可以使用 DownTo 指令：

```xs
SumValue = 0;
For i = 4 downto 0
Begin
	SumValue = SumValue + Close[i];
End;
AvgValue = SumValue / 5;
```

上述範例執行的結果與先前相同，唯一的差異是 DownTo 語法，所以迴圈執行的方式是第一次 i = 4，第二次 i = 3（遞減），第三次 i = 2，第四次 i = 1，最後一次 i = 0。

一般而言迴圈的執行次數是透過初始值跟結束值來控制的，可是如果需要在執行過程內提前跳出的話，則可以使用 Break 指令。

系統內還提供不同的迴圈控制方式，請參考 Repeat/Until 以及 While。

---

### [Once](https://xshelp.xq.com.tw/XSHelp/api?a=Once&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Once 語法用來定義某些只需要執行一次的程式碼。

**範例 1:**

```xs
Once(High = Highest(High, 5))
Begin
    HighDate = Date;
    HighPrice = High;
End;
```

Once 語法之後必須填入一個判斷式，以上例而言，這個判斷式是 `High = Highest(High, 5)`，在判斷式之後，可以填入當判斷式成立時要執行的指令，如果有多行指令的話則可以使用 Begin/End 來包圍。

所以上面這個範例執行的邏輯是，當創 5 日新高時，執行 `HighDate = Date` 以及 `HighPrice = High` 這兩個指令，而且一旦出現創 5 日新高的情形之後，就不再執行這兩個指令。

**範例 2 - 使用 IF 達到同樣效果:**

如果要達到同樣的目的，也可以使用 IF 指令，搭配一個紀錄是否曾經執行過的變數：

```xs
Var: FirstTime(False);
If High = Highest(High, 5) And Not FirstTime Then
Begin
    HighDate = Date;
    HighPrice = High;
    FirstTime = True;
End;
```

在上述範例內，程式使用 FirstTime 這個變數來紀錄這個 IF 狀態是否曾經發生過，以確保只會執行一次。

可是由於系統會根據執行的設定方式在每一筆 bar 甚至每一筆 tick 更新時都會執行完整的程式碼，所以如果是使用 If 的寫法的話，每一次執行時還是會去判斷 High 是否等於 Highest(High, 5)！反之，如果是使用 Once 的寫法的話，一旦 Once 的運算式成立之後，未來不管執行任意 bar，系統都會自動跳過 Once 的判斷式以及程式碼。由於在這個例子內，IF 內所需要執行的指令比較複雜且費時，所以就可以使用 Once 的語法來提升執行的速度。

---

### [Switch / Case / Default](https://xshelp.xq.com.tw/XSHelp/api?a=Switch&b=controlflow)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

Switch 語法是用來判斷某個變數的值是否符合某些運算式，同時定義符合時的執行指令。

**語法:**

```xs
Switch (變數)
Begin
  Case 運算式1:
     符合運算式1時所執行的指定;
  Case 運算式2:
     符合運算式2時所執行的指定;
  Default:
     都不符合時所執行的指令;
End;
```

在 Switch 語法內必須傳入一個變數，同時使用 Case 語法定義各種不同的運算式，以及當這個運算式符合時要執行的指令。同時也可以使用 Default 語法來定義當所有的 Case 都不符合時所需要執行的指令。

**範例:**

```xs
Value1 = DayOfMonth(date);
Switch (value1)
Begin
  Case 1:   // value1=1時執行這段程式碼
		print(Text("今天的日期是",numtoStr(date,0),
		"。是",numtoStr(DayOfMonth(date),0),"日")
		,"value1=1時執行這段程式碼");

  Case 2:   // value1=2時執行這段程式碼
		print(Text("今天的日期是",numtoStr(date,0),
		"。是",numtoStr(DayOfMonth(date),0),"日"),
		"value1=2時執行這段程式碼");

  Case 6 to 20: // value1= 6 ~ 20 時執行這段程式碼
		print(Text("今天的日期是",numtoStr(date,0),
		"。是",numtoStr(DayOfMonth(date),0),"日"),
		"value1=6~20時執行這段程式碼");

  Default:  // 其他情形都執行這段程式碼
		print(Text("今天的日期是",numtoStr(date,0),
		"。是",numtoStr(DayOfMonth(date),0),"日"),
		"其他情形都執行這段程式碼");
End;
```

---

### [If / Then / Else](https://xshelp.xq.com.tw/XSHelp/article?a=If_Then_Else)

| 項目     | 內容     |
| :------- | :------- |
| **分類** | 流程控制 |

**說明:**

使用 IF/THEN/ELSE 這三個語法來判斷某個條件成立時該執行那個動作，不成立時又該執行那個動作。

**範例 1 - 基本用法:**

```xs
If Close > Open Then Ret = 1;
```

在上述範例內如果 Close 值大於 Open 值的話則 Ret 變數的數值會被設定為 1。

**範例 2 - 多行指令:**

如果當條件成立時需要執行多個指令的話，則使用 Begin/End 的語法來包圍所需要執行的指令：

```xs
If Close > Open Then
Begin
	Value1 = Close - Open;
	Value2 = High - Low;
End;
```

**範例 3 - ELSE:**

如果條件成立時跟不成立時都需要執行不同的指令的話，則可以加入 ELSE 語法來定義條件不成立時該執行的動作：

```xs
If Close > Open Then
	Value1 = Close - Open
Else
	Value1 = Open - Close;
```

在上述範例內當 Close 的數值不大於 Open 的數值時，程式會執行 Else 內的語法。以這個例子為例，Value1 的數值就是這根 bar 的實體高度。

**範例 4 - ELSE IF:**

Else 後面也可以接 if，用 else if 來進行多層次的條件判斷，從腳本上至下依序縮小判斷範圍：

```xs
if value1 < 0 then
	value2 = 1
else if value1 < 10 then // 等同於 if 0 <= value1 and value1 < 10
	value2 = 2
else if value1 < 20 then // 等同於 if 10 <= value1 and value1 < 20
	value2 = 3
else  // 等同於 if 20 <= value1
	value2 = 4;
```

---

## 宣告

### [TrueFalseArrayRef](https://xshelp.xq.com.tw/XSHelp/api?a=TrueFalseArrayRef&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

TrueFalseArrayRef 語法用來定義函數腳本的參數為邏輯值陣列型態，並且可以從函數內修改呼叫者傳入的邏輯值陣列。

**語法:**

```xs
Input: MyFlagArray[X](TrueFalseArrayRef);
```

TrueFalseArrayRef 可以視為 TrueFalseArray 以及 TrueFalseRef 的綜合體。請參考以上兩種語法的說明。

---

### [TrueFalseArray](https://xshelp.xq.com.tw/XSHelp/api?a=TrueFalseArray&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

TrueFalseArray 語法用來定義函數腳本的參數為邏輯值陣列型態。

**語法:**

```xs
Input: MyFlagArray[X](TrueFalseArray);
```

相關的語法請參考 NumericArray

---

### [TrueFalseRef](https://xshelp.xq.com.tw/XSHelp/api?a=TrueFalseRef&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

TrueFalseRef 語法用來定義函數腳本的參數為邏輯值型態，並可以從函數內修改呼叫者傳入的數值。

**語法:**

```xs
Input: MyFlag(TrueFalseRef);
```

關於從函數內回傳數值的行為，請參考 NumericRef

---

### [TrueFalse](https://xshelp.xq.com.tw/XSHelp/api?a=TrueFalse&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

TrueFalse 語法用來定義函數腳本的參數為邏輯值型態（TRUE 或是 FALSE）。

**語法:**

```xs
Input: MyFlag(TrueFalse);
```

TrueFalse 型態也有兩種變形：

- **TrueFalseSeries:** 代表傳入的是一個邏輯值序列
- **TrueFalseSimple:** 代表傳入的是一個邏輯值的單一值

相關的語法請參考 Numeric

---

### [StringArrayRef](https://xshelp.xq.com.tw/XSHelp/api?a=StringArrayRef&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

StringArrayRef 語法用來定義函數腳本的參數為字串陣列型態，並且可以從函數內修改呼叫者傳入的字串陣列。

**語法:**

```xs
Input: MyStringArray[X](StringArrayRef);
```

StringArrayRef 可以視為 StringArray 以及 StringRef 的綜合體。請參考以上兩種語法的說明。

---

### [StringArray](https://xshelp.xq.com.tw/XSHelp/api?a=StringArray&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

StringArray 語法用來定義函數腳本的參數為字串陣列型態。

**語法:**

```xs
Input: MyStringArray[X](StringArray);
```

相關的語法請參考 NumericArray

---

### [StringRef](https://xshelp.xq.com.tw/XSHelp/api?a=StringRef&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

StringRef 語法用來定義函數腳本的參數為字串型態，並可以從函數內修改呼叫者傳入的數值。

**語法:**

```xs
Input: MyString(StringRef);
```

關於從函數內回傳數值的行為，請參考 NumericRef

---

### [String](https://xshelp.xq.com.tw/XSHelp/api?a=String&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

String 語法用來定義函數腳本的參數為字串型態。

**語法:**

```xs
Input: MyString(String);
```

String 型態也有兩種變形：

- **StringSeries:** 代表傳入的是一個字串序列
- **StringSimple:** 代表傳入的是一個字串的單一值

相關的語法請參考 Numeric

---

### [NumericArrayRef](https://xshelp.xq.com.tw/XSHelp/api?a=NumericArrayRef&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

NumericArrayRef 語法用來定義函數腳本的參數為數值陣列型態，並且可以從函數內修改呼叫者傳入的數值陣列。

**語法:**

```xs
Input: MyNumericArray[X](NumericArrayRef);
```

NumericArrayRef 可以視為 NumericArray 以及 NumericRef 的綜合體。請參考以上兩種語法的說明。

---

### [NumericArray](https://xshelp.xq.com.tw/XSHelp/api?a=NumericArray&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

NumericArray 語法用來定義函數腳本的參數為數值陣列型態。

**語法:**

```xs
Input: MyNumericArray[X](NumericArray);

For Value1 = 1 to X
  Value2 = Value2 + MyNumericArray[Value1];
```

NumericArray 與 Numeric 最大的差異是在 Input 語法內陣列變數名稱之後還需要定義 **[陣列大小變數]**。在上例內 `[X]` 就宣告了一個變數 X，他的數值會是傳入的陣列的大小（陣列內有多少數值）。

透過這個機制，函數內就可以知道傳入的陣列的大小，然後利用這個資訊來正確的判斷可以讀取哪些數值。

上述範例內使用一個 For 迴圈來加總傳入陣列的每個數值，迴圈的範圍是從 1 開始，直到 X 結束。

如果需要傳入的陣列是二維的，則語法如下：

```xs
Input: MyNumericArray[X,Y](NumericArray);
```

在上例內中括弧內必須填入兩個變數（X, Y），這兩個變數的數值將會分別是傳入的陣列的行數跟欄數。

---

### [NumericRef](https://xshelp.xq.com.tw/XSHelp/api?a=NumericRef&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

NumericRef 語法用來定義函數腳本的參數為數值型態，並且可以從函數內修改呼叫者傳入的數值。

當一個函數變數被宣告成 Numeric 時，在函數內對這個數值的修改並不會影響呼叫者端傳入的變數，這個行為稱之為 **Call By Value**。

如果有需要從函數內可以更改呼叫者端的變數的話，則可以使用 NumericRef 的語法，此時的行為會變成 **Call By Reference**。

**範例 - MACD 函數:**

```xs
// MACD function
//  Input: Price序列, FastLength, SlowLength, MACDLength
//  Output: DifValue, MACDValue, OscValue
//
Input: Price(numericseries);
Input: FastLength(numericsimple);
Input: SlowLength(numericsimple);
Input: MACDLength(numericsimple);

Input: DifValue(numericref);
Input: MACDValue(numericref);
Input: OscValue(numericref);

DifValue = XAverage(price, FastLength) - XAverage(price, SlowLength);
MACDValue = XAverage(DifValue, MACDLength);
OscValue = DifValue - MACDValue;
```

在上述 MACD 函數內，呼叫者端傳入了價格序列（Price）、短天期（FastLength）、長天期（SlowLength），以及 MACD 的天期（MACDLength），函數內要算出 DIF 的數值、MACD 的數值、以及 OSC 的數值。由於總共有三個數值需要回傳，所以利用 NumericRef 的方式來完成。

**呼叫者端的程式碼範例:**

```xs
input: FastLength(12), SlowLength(26), MACDLength(9);
variable: difValue(0), macdValue(0), oscValue(0);

MACD(Close, FastLength, SlowLength, MACDLength, difValue, macdValue, oscValue);

Ret = difValue Crosses Above macdValue;
```

注意到當呼叫完 MACD 函數後，difValue、macdValue、以及 oscValue 的數值都會從 MACD 函數內回傳。

---

### [Numeric](https://xshelp.xq.com.tw/XSHelp/api?a=Numeric&b=declaration)

| 項目         | 內容               |
| :----------- | :----------------- |
| **分類**     | 宣告               |
| **適用範圍** | 僅適用於函數腳本內 |

**說明:**

Numeric 語法是用來定義函數腳本的參數為數值型態。

**語法:**

```xs
Input: Price(Numeric);
Input: Length(Numeric);

Value1 = Summation(Price, Length) / Length;
```

假設上例是一個名稱為 MyFunction 的函數，在此 Price 參數跟 Length 參數都被定義成 Numeric，表示使用這個函數的腳本必須傳遞數值型態的參數，否則腳本編譯時會產生錯誤。

以下是使用這個函數的腳本的範例：

```xs
Value1 = MyFunction(Close, 5);
```

在上例內呼叫 MyFunction 時傳入了 Close（收盤價序列），以及數值 5。

**Numeric 變形:**

Numeric 型態還有以下兩個變形：

- **NumericSeries:** 表示傳入的數值為一個序列，例如傳入 Close（收盤價序列）
- **NumericSimple:** 表示傳入的數值為一個單一數值，例如 5

這兩種變形的用意是要幫忙系統可以更精確的處理腳本跟函數之間的運作關係。

```xs
Input: Price(NumericSeries);
Input: Length(NumericSimple);

Value1 = Summation(Price, Length) / Length;
```

在這個函數內，由於 Price 是被當成序列來使用（計算加總時會用到前期值），所以可以宣告成 NumericSeries。而 Length 因為只會用到當下的數值，所以可以宣告成 NumericSimple。

目前 XS 系統內，只要是數值參數，腳本內可以混用 Numeric、NumericSimple、以及 NumericSeries 這三種宣告方式，不影響腳本執行的結果。

---

### [inputkind](https://xshelp.xq.com.tw/XSHelp/api?a=inputkind&b=declaration)

| 項目     | 內容 |
| :------- | :--- |
| **分類** | 宣告 |

**說明:**

input 宣告的時候，可以使用 inputkind 這個命名參數（named parameter），用來控制系統參數設定的介面（UI）。再搭配 Dict、DateRange 或 SymbolPrice 函數來產生對應的內容。

**範例 1 - Dict 產生選項:**

```xs
input: IndexPomUnit(1, "大盤融資單位", inputkind:=Dict(["金額",1],["張數",2]));
```

在上述的範例內宣告了一個名為 IndexPomUnit 的參數，用來存放計算大盤融資的數值，不過此數值的單位有金額與張數兩種，故可以使用 inputkind 搭配 Dict 函數，就能在介面設定單位為金額或者張數，此範例預設單位為金額。

也可以改寫成以下範例，使用字串型態的方式來撰寫相關程式碼：

```xs
input: IndexPomUnit("Amount", "大盤融資單位", inputkind:=Dict(["金額","Amount"],["張數","Sheets"]));
```

**範例 2 - DateRange 產生日期範圍選項:**

```xs
input:FdifferenceDate(20180301,"外資買賣超查詢日期",inputkind:=daterange(20160301,20190301,"D"));
// daterange(最小查詢日期,最大查詢日期,"支援日/週/月/季/半年/年頻率")
```

在上述的範例內宣告了一個名為 FdifferenceDate 的參數，用來存放外資買賣超查詢日期的數值，就能方便在介面上勾選日曆選項使用，此範例預設查詢日期為 2018 年 03 月 01 日。

**範例 3 - SymbolPrice 產生 OHLC 選項:**

```xs
input:OHLC_Opti(200,"價格：",inputkind:=SymbolPrice());
```

在上述的範例中，宣告了一個名為 OHLC_Opti 的參數，用來存放價格的數值，就能方便在介面上勾選 Open、High、Low、Close 四個選項使用。

---

### [Input](https://xshelp.xq.com.tw/XSHelp/api?a=Input&b=declaration)

| 項目     | 內容 |
| :------- | :--- |
| **分類** | 宣告 |

**說明:**

Input 語法用來宣告腳本參數的名稱以及資料類型（也可以寫成 Inputs）。

Input 的語法依照腳本類型而有差異。

**指標/警示/選股腳本:**

如果是指標腳本、警示腳本、或是選股腳本的話，則使用以下語法。以下是一個指標的範例：

```xs
Input: Length(10);

Plot1(Average(Close, Length));
```

在上述的指標範例內宣告了一個名為 Length 的參數，用來存放計算收盤價平均值的天期。這個參數的預設值為 10，資料類型為數字。

一旦宣告之後，程式內則可以像變數 Var 一樣的使用這個參數。可是跟變數不同的是，使用者在使用這個腳本時，可以透過參數設定的畫面來動態控制這個參數的數值。

如果希望畫面上看到的參數名稱是中文的話，則可以在 Input 語法內傳入參數名稱：

```xs
Input: Length(10, "天期");

Plot1(Average(Close, Length));
```

**函數腳本:**

Input 語法如果應用在函數腳本內的話，則必須使用不同的語法：

```xs
Input: Price(NumericSeries);
Input: Length(NumericSimple);

Value1 = Summation(Price, Length) / Length;
```

在上述範例內宣告了兩個參數，第一個參數叫做 Price，他的資料格式是一個數字序列，第二個參數叫做 Length，他的資料格式是一個數字（不是序列）。

加上參數名稱：

```xs
Input: Price(NumericSeries,"價格");
Input: Length(NumericSimple,"天期");
```

加上預設值和參數名稱：

```xs
Input: Price(close,NumericSeries,"價格");
Input: Length(10,NumericSimple,"天期");
```

關於函數所支援的各種不同的參數類型，請參考以下章節：

- Numeric / NumericSimple / NumericSeries / NumericRef / NumericArray / NumericArrayRef
- String / StringSimple / StringSeries / StringRef / StringArray / StringArrayRef
- TrueFalse / TrueFalseSimple / TrueFalseSeries / TrueFalseRef / TrueFalseArray / TrueFalseArrayRef

---

### [Array](https://xshelp.xq.com.tw/XSHelp/api?a=Array&b=declaration)

| 項目     | 內容 |
| :------- | :--- |
| **分類** | 宣告 |

**說明:**

Array 語法用來宣告一個陣列變數，同時設定陣列的大小以及陣列內儲存數值的資料型態（也可以寫成 Arrays）。

所謂陣列就是一個可以儲存多個數值的變數，陣列內儲存數值的個數，以及數值的資料型態可以透過 Array 語法來定義。

**固定大小陣列:**

```xs
Array: NumArray[10](0);
Array: StrArray[10]("");
Array: BoolArray[10](True);
```

在以上的範例設定了三個陣列變數：

- **NumArray**：這是一個數值陣列，總共有 10 個數值，每個數值的初始值都是 0
- **StrArray**：這是一個字串陣列，總共有 10 個數值，每個數值的初始值都是 ""
- **BoolArray**：這是一個布林值陣列，總共有 10 個數值，每個數值的初始值都是 True

**存取陣列:**

```xs
NumArray[1] = 5;
Value1 = NumArray[1];
```

在中括弧 `[]` 內傳入的數值稱之為索引值，索引值的範圍由 1 開始，一直到陣列宣告的最大個數。

**動態大小陣列:**

如果陣列的大小無法預先知道的話，則可以使用第二種語法來宣告陣列：

```xs
Array: NumArray[](0);
Array: StrArray[]("");
Array: BoolArray[](True);
```

等到程式知道陣列的實際所需大小時，程式必須透過 `Array_SetMaxIndex` 函數來設定陣列的大小：

```xs
Var: Count(0);
Array: NumArray[](0);

If High > Highest(High,20)[1] Then Count = Count + 1;

Array_SetMaxIndex(NumArray, Count);
NumArray[Count] = High;
```

**二維陣列:**

```xs
Array: NumArray[10,2](0);
```

存取二維陣列：

```xs
NumArray[5,1] = 10;
Value1 = NumArray[1,2];
```

> **注意:** Array 維度最多 9 個。元素數量最多 7000。

---

### [IntrabarPersist](https://xshelp.xq.com.tw/XSHelp/api?a=IntrabarPersist&b=declaration)

| 項目     | 內容 |
| :------- | :--- |
| **分類** | 宣告 |

**說明:**

IntrabarPersist 語法用來控制變數數值在執行時的變化邏輯。

在程式執行時，變數的數值會自動延續前一筆 bar 最後的計算值。

如果腳本被設定成逐筆洗價的話（也就是說同一筆 bar 可能執行很多次），每次執行時，變數的數值還是都會先變成上一筆 bar 最後執行的結果之後才開始執行。

這個行為是為了要保證逐筆洗價時最後算出來的數值只跟這一筆 bar 的價位有關，而不是跟這一筆 bar 被執行了多少次有關。

可是在某些情境底下可能需要保留最後一次計算後的數值（不管是否有換 bar），此時就可以使用 IntrabarPersist 的語法：

**範例:**

```xs
input: atVolume(100); setinputname(1,"大單門檻");

variable: intrabarpersist Xtime(0);         //計數器

Volumestamp = q_DailyVolume;

if Date > date[1] then Xtime = 0; // 開盤那根要歸0次數

if q_tickvolume > 100 then Xtime += 1; // 量夠大就加1次

if Xtime > 10 then
begin
	ret = 1;
	Xtime = 0;
end;
```

上述範例是一個警示腳本，使用日線頻率，逐筆洗價模式來執行。我們希望當大單（目前定義成單筆成交量 > 100 張）的個數超過 10 之後就觸發。由於是日線模式，所以每次重新執行時 XTime 都會變成 0，無法實際統計發生大單的次數。

解決方式則是把 XTime 設為 IntrabarPersist。一旦這樣設定之後，XTime 的數值就不會因為重新執行這根 bar 而被還原，也因此可以正確的統計到在當日出現大單的個數。

---

### [Var](https://xshelp.xq.com.tw/XSHelp/api?a=Var&b=declaration)

| 項目     | 內容 |
| :------- | :--- |
| **分類** | 宣告 |

**說明:**

Var 語法用來宣告變數，並且給定變數的預設值。

系統會根據 Var 語法內給定的預設值的型態來決定變數的類型。目前系統提供以下三種變數類型：

- **數值**：例如 10, 5.3
- **字串**：例如 "String"
- **邏輯值**：例如 True, False

**語法:**

```xs
Var: SumValue(0);
Var: StrValue("");
Var: Flag(True);
```

在上述的範例內宣告了三個變數：

- **SumValue** 是一個數值變數，初始值為 0
- **StrValue** 是一個字串變數，初始值為 ""（空白字串）
- **Flag** 是一個邏輯變數，初始值為 True

多個變數也可以在同一行內宣告，例如可以把上述範例寫成：

```xs
Var: SumValue(0), StrValue(""), Flag(True);
```

除了 Var 語法之外，也可以使用 **Vars** 語法、**Variable** 語法、或是 **Variables** 語法來宣告變數，範例如下：

```xs
Vars: SumValue(0);
Variable: StrValue("");
Variables: Flag(True);
```

---

### [SymbolGroup](https://xshelp.xq.com.tw/XSHelp/?HelpName=SymbolGroup&group=DECLARATION)

| 項目     | 內容 |
| :------- | :--- |
| **分類** | 宣告 |

**說明:**

SymbolGroup 是用來在指標腳本的 input 中設定清單類型的語法，搭配 inputkind 和 quickedit 即可以在指標設定中透過選單來快速切換執行商品對應的清單。

詳細說明可參考商品清單功能。

**範例:**

以下範例：取得執行商品相關的可轉債並畫出，當有執行商品多個可轉債時可以在線圖上作快速切換。

```xs
Input:cb_id("", InputKind:=SymbolGroup("CB"), QuickEdit:=true);
plot1(GetSymbolField(cb_id, "Close"));
```

---

### [Group](https://xshelp.xq.com.tw/XSHelp/?HelpName=Group&group=DECLARATION)

| 項目     | 內容 |
| :------- | :--- |
| **分類** | 宣告 |

**說明:**

Group 是用來宣告清單的語法，接著可以在腳本內透過使用 GetSymbolGroup 來取得和執行商品相關的清單。

詳細說明可參考商品清單功能。

**範例:**

以下範例：宣告一個名為 myGroup 的清單並讓其取得執行商品的成分股。

```xs
Group: myGroup();
myGroup = GetSymbolGroup("成分股");
```

---
