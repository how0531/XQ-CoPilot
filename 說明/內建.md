# XS 內建函數參考

### Short

Short(空單加碼數量)

**說明:**

交易函數\nShort(空單加碼數量，委託價格)\nShort(空單加碼數量，label:="指令標記")\nShort(空單加碼數量，委託價格，label:="指令標記")\nShort函數的第一個參數是加碼部位，必須是一個正整數。第二個參數是此次交易的委託價格，第二個參數如果不傳的話則會使用策略的預設賣出價格。\n與SetPosition一樣，也可以透過label函數傳入指令標記。

**範例:**

```xs
Short(1);
Short(1, Close);
Short(1, MARKET);
Short(1, label:="放空1張");
```

**注意事項:**

> 當目前的Position > 0時，執行Short指令時會先把多頭部位全部平倉(部位變成0)，之後再進行空單加碼的動作。
> Short(0)是一個特殊用法，如果此時的部位大於0的話，Short(0)的作用是把部位變成0，如果此時的部位小於0的話，則Short(0)沒有任何作用。
> 以下是Short(N)的執行邏輯：
> if Position > 0 then
> 2 SetPosition(-1 \* N) { 從Position(正數)變成 -N }
> else
> 4 SetPosition(Position - N); { 從Position(0或是負數)變成 Position-N }

---

### SetPosition

SetPosition(目標部位)

**說明:**

交易函數\nSetPosition(目標部位，委託價格)\nSetPosition(目標部位，label:="指令標記")\nSetPosition(目標部位，委託價格，label:="指令標記")\n部位(Position)是XS自動交易語法內最重要的觀念，在自動交易策略執行過程內，每個商品會有一個Position的數值，這個數值可以是0(空手)、大於0(多單)、或是小於0(空單)。\n當腳本希望作買進的動作時，腳本可以透過SetPosition(或是其他交易函數)，把目標部位變大，例如如果目前Position是0的話，腳本可以呼叫SetPosition(1)，表示希望買進1張。同樣的，如果腳本希望作賣出的動作時，腳本可以透過SetPosition(或是其他函數)，把目標部位變小。\n當腳本呼叫SetPosition(或是其他交易函數)時，系統會比對目前的Position以及新的目標部位的差異，然後送出對應的委託單，如果這些委託單完全成交的話，商品的淨成交部位就會跟目標部位是一樣的。

**範例:**

```xs
SetPosition(1);
```

把腳本的部位變成1，委託價格使用策略預設的買賣價格。如果原先的Position是0的話，這個指令會買進1張，如果原先的Position是2的話，這個指令會賣出1張。如果原先的Position是1的話，這個指令會檢視目前委託的執行情形，可能會送出改價的委託(如果原先委託尚未成交，且這一次的委託價格跟上一筆委託單的委託價格不一樣的話)，或是不做任何動作。詳細的執行邏輯請參考底下「交易指令的執行方式」的說明。

```xs
SetPosition(1, Close);
```

把腳本的部位變成1，委託價格使用目前的收盤價。SetPosition的第二個參數是委託價格，可以傳入一個固定數值(例如100.0)，或是其他的數值運算(例如Close, Close+1.0, 等)。

```xs
SetPosition(-1);
```

把腳本的部位變成-1，委託價格使用策略預設的買賣價格。如果原先的Position是0的話，這個指令會賣出1張，如果原先的Position是-2的話，這個指令會買進1張。

```xs
SetPosition(-1, MARKET);
```

把腳本的部位變成-1，委託價格使用市價。系統會依照帳號類型來決定市價單該如何傳送，如果是證券帳號的話，會傳送市價委託，如果是期貨帳號的話，則會傳送範圍市價委託。

```xs
SetPosition(Position+1, AddSpread(Close, 1));
```

把腳本的部位變成目前的Position再加1張，所以不管原先的Position是多少，這個指令都會買進1張。委託的價格則是目前收盤價再往上加一檔。
Position是一個內建的欄位，腳本可以透過這個欄位取得目前的部位數值。
AddSpread函數可以用來計算加減檔數後的價格。
除了SetPosition語法可以改變腳本部位之外，系統同時還提供Buy、Sell、Short、Cover這幾種語法，請參考相關說明。

```xs
SetPosition(1, label:="我的標記");
```

假設策略的Position設定從0開始，接下來的SetPosition(1)，指的是買進1張，如果成交的話，Filled也會是1，這兩個數值與帳號的庫存數值，就可能是不一樣的。

```xs
GetField("漲停價", "D")
GetField("跌停價", "D")
SetPosition(1, MARKET)
SetPosition(1, AddSpread(Close, 2))
SetPosition(-1, AddSpread(Close, -2))
```

SetPosition的第一個參數是目標部位，系統預期腳本會傳入一個整數的數值(可以是0、大於0或是小於0)。
如果腳本傳入的目標部位不是整數的話，則一律捨去小數位數，例如如果呼叫SetPosition(1.5678)的話，系統會以SetPosition(1)的方式來處理。
由於不同的商品有每次交易最大數量的限制(例如台股每一筆委託單只能送出499張)，如果SetPosition傳入的目標部位與先前的部位的差異超過這個限制的話，為了安全起見，執行時系統會回傳錯誤(超過單筆委託限制)，同時停止這個商品的執行。
可以透過label這個參數, 傳入這次SetPosition的標記名稱。請參考底下交易指令的標記名稱的說明。
Position跟Filled的關係
Position欄位代表腳本的預期部位，而Filled欄位則是到目前為止的成交部位。簡單的來說，當腳本呼叫SetPosition傳入預期部位之後，系統就會依照SetPosition的參數來傳送委託，當收到成交時就會更新Filled欄位，如果Position跟Filled兩個欄位的數值一模一樣時，代表的是目前腳本的部位狀態與使用者的預期是一致的。
關於Position跟Filled，還有兩個地方要務必注意：
第一：一個自動交易策略可能會執行多個商品，每個商品的Position/Filled都是互相獨立的。
第二：Position/Filled的數值是一個相對的數值，與使用者所指定的交易帳號內這個商品的庫存部位未必是一樣的。例如我的交易帳號內可能有0050的庫存2張，可是XS自動交易策略提供多種設定策略部位的方式，可以把Position設定從0開始，或是從2開始，甚至也可以設定成從1開始。
委託價格參數
如果SetPosition函數不傳入委託價格的話，則傳送委託時會依照交易策略的預設委託價格設定決定要使用那個價格，請注意交易策略的預設委託價格可以依照買進/賣出分別指定。
如果想要指定委託價格的話，則可以在第二個參數內傳入一個固定數值，或是一個數值運算式，例如
100.0
Close, High, Low
也可以傳入系統內定的市價參數(MARKET)，代表要用市價來交易。例如
如果傳入MARKET的話，系統會依照帳號類型來決定市價單該如何傳送，如果是證券帳號的話，會傳送市價委託，如果是期貨帳號的話，則會傳送範圍市價委託。
系統也支援檔位計算的函數(AddSpread)，例如：
為了保證委託價格符合商品的交易限制，在執行時系統會做以下的價格處理：
以台積電(2330)為例，
首先，先依照商品的小數點位數做四捨五入，例如298.765會先被轉成298.77，
接著如果這個價格不符合商品的跳動點的話，則會依照買進或是賣出做不同方式的轉換。如果是買進的話，價格會被轉成往下第一個符合跳動點的價格，如果是賣出的話，則會被轉成往上第一個符合跳動點的價格：
如果是買進，298.77會被轉成298.5 (每一跳動點0.5)
如果是賣出的話，298.77會被轉成299.0
如果商品有漲跌停限制的話，則系統會保證價格不會超過漲跌停。
委託數量的處理
交易指令的標記名稱
SetPosition所需傳入的參數除了目標部位以及委託價格之外，還可以另外透過label參數，傳入一個字串（字串長度最多64個字)，代表這個交易指令的名稱，當這個交易指令成交時，通知的UI上可以看到這個名稱文字，方便使用者辨識這次的成交原因。

```xs
condition1 = Average(Close, 5) cross over Average(Close, 10);
condition2 = TrueAll(Close > Close[1], 5);
if condition1 then SetPosition(1, label:="均線穿越");
if condition2 then SetPosition(1, label:="連漲5筆");
var: entry_condition(false), exit_condition(false);
entry_condition = Average(Close, 5) cross over Average(Close, 20);
exit_condition = Average(Close, 5) cross below Average(Close, 20);
if Position = 0 and entry_condition then SetPosition(1);
if Position = 1 and exit_condition then SetPosition(0);
```

我們知道當腳本發現Position是0，而且entry_condition是true的時候，腳本會呼叫SetPosition(1)。
那麼腳本呼叫完SetPosition(1)之後，在下一行執行時Position會馬上變成1嗎？
這兩個變數的數值在執行這一次腳本的過程內都不會改變。當這次腳本執行結束之後，系統知道這次執行時呼叫了SetPosition(1)，所以在執行腳本完成後，才會把Position的數值改成1，同時準備送出委託單。
規則#2: 這兩個數值在執行腳本(洗價)的過程之間都不會改變。不會因為腳本呼叫了SetPosition之後就馬上改變Position的數值，也不會因為在這一次執行腳本(洗價)期間收到了成交而馬上改變Filled的數值。

```xs
if condition1 then SetPosition(1);
if condition2 then SetPosition(2);
if condition3 then SetPosition(3);
```

在上面這個範例內，有可能因為condition1，condition2，condition3的狀態而呼叫了不同的交易指令，甚至先呼叫了SetPosition(1)，然後又呼叫了SetPosition(3)。當遇到這種情形時，系統會如何決定要執行哪一個交易指令呢？
目前XS自動交易的執行方式是只執行第一個交易指令，忽略之後的交易指令。以上面腳本範例而言，如果condition1是false，condition2是true，condition3也是true的話，那麼當次洗價的第一個交易指令是SetPosition(2)，所以系統會執行這一個，至於之後呼叫的SetPosition(3)則予以忽略。
範例#1: SetPosition(1)，買進1張後成交，SetPosition(0)，賣出1張
我們先舉一個最簡單的例子，假設腳本呼叫了SetPosition(1)：
接續先前的例子，如果接下來腳本呼叫了SetPosition(0)的話，因為目前的Position是1，新的目標部位是0，所以系統會送出一筆賣出1張的委託單，委託價格則是策略預設的賣出價格。
範例#2: SetPosition(1)，買進1張後未成交，SetPosition(0)，執行刪單
接下來我們考慮另外一種執行的情形，同樣的腳本先呼叫了SetPosition(1)，然後系統送出了一筆買進1張的委託單，Position變成1，Filled還是0(尚未成交)。
假如在這一筆委託單還沒有成交之前，腳本就呼叫了SetPosition(0)。此時會發生什麼情形呢？
範例#3: SetPosition(1)，買進1張後成交，SetPosition(2)，再買進1張
接下來我們來看部位加碼的執行方式。假設腳本先呼叫了SetPosition(1)，然後這一張成交了，此時Position是1，Filled也是1。
假如接下來腳本呼叫了SetPosition(2)的話，系統比對目前的Position是1，目標Position是2，所以送出了一筆買進1張的委託，送出後Position = 2，在還沒有成交前，Filled是1，等到成交之後，Filled就會變成2。
範例#4: SetPosition(1)，買進1張後沒有成交，SetPosition(2)，刪除先前委託改成買進2張
延續範例#3的情境，假設腳本先呼叫了SetPosition(1)，在這一筆買進1張的委託尚未成交之前，腳本又呼叫了SetPosition(2)，此時系統會怎麼執行呢？
目前XS採用的方式是比較簡單的作法：當系統執行SetPosition(2)時，如果發現先前的委託單尚未完成成交的話，執行的邏輯是先刪除這一張委託，然後依照這一張委託的成交數量決定如何傳送下一筆委託：
範例#5: SetPosition(1)，買進1張後沒有成交，再次收到SetPosition(1)，刪除先前委託，改送不同價格的委託
我們接下來看另外一種情境，假設腳本先呼叫SetPosition(1, 100.0)，此時送出了一筆買進1張的委託，委託價格是100.0。
假設在這一筆委託還沒有成交前，腳本又呼叫了SetPosition(1, 99.0)，此時系統發現新的部位雖然跟原先部位一樣，可是因為還沒有成交，而且委託價格不一樣，所以此時系統會刪除原先的委託，然後改送一筆買進1張的委託，委託價格是99.0。

```xs
value1 = CurrentBar;
SetPosition(1);
value1 = CurrentBar;
SetPosition(1, AddSpread(Close, 5));
```

在這個腳本內我們發現Position是1，Filled還是0，而且離上一次下單已經超過2根bar了，通常會發生這樣子的情形可能是商品的價格已經超過先前委託的價格。此時可以使用SetPosition傳入不同價格的方式來告訴系統我想要改用不同的委託價格。當執行到 SetPosition(1, AddSpread(Close, 5))時，系統就會刪除原先的委託，然後改用新的委託價格來送單。
if Position = 0 then begin
end;
為了避免混淆，同一個腳本內的交易指令的標記名稱必須是唯一的。
Position異動的時機點
我們看以下的腳本範例，這是一個很常見的進場+出場的交易情境：
2
3
6
7
這個問題的答案是：不會。
在每一次系統執行腳本前，系統會決定當時的Position以及Filled的數值。
如果接下來商品收到了價格異動，再次執行腳本的話，此時Position的數值就會是1，而Filled的數值則依照當時是否已經收到了成交來決定是0還是1。
規則#1: 系統會在執行腳本(洗價)前決定Position跟Filled的數值。
交易指令的優先順序
如果一個腳本內有多個交易指令的話，那系統怎麼決定要執行哪些交易指令呢？我們看以下的範例：
交易指令的執行方式
當系統收到了SetPosition指令時，系統會依照以下狀態來判斷如何執行這一筆交易指令：
目前的Position(執行這一個交易指令之前的Position數值)，
目前的成交部位(在腳本內稱之為Filled，代表這個商品執行到目前為止的淨成交張數)，
是否先前的交易指令還有尚未完全成交的委託單
腳本在剛開始執行時，預設的Position是0，SetPosition這個指令傳入的目標部位是1，所以系統會送出一筆買進1張的委託單，委託價格則是策略預設的買進價格。
執行之後，Position會變成1。在這一筆委託單還沒有成交之前，Filled是0。等到這一筆委託單成交了，則Filled變成1。
執行之後，Position會變成0。此時Filled的數值還是是1，等到這一筆賣出委託成交之後，Filled的數值就會變成0。
因為這一筆委託單尚未成交，所以如果要讓Position變成是0的話，最直接的執行方式是在這一筆買進1張的委託尚未成交之前，就先刪除這一筆委託。如果可以順利刪除的話，就符合使用者的預期部位了！
一種可能的執行方式是保留原先的買進1張的委託，另外再送出一張買進1張的委託，這樣子當兩張都成交時就會符合使用者的預期。
可是這樣子的執行方式比較複雜，爾後假如這兩張委託都沒有成交之後，使用者又更改Position的話，執行的邏輯會越來越難掌握。
假設刪除委託後沒有成交，此時使用者的實際成交部位是0，而腳本預期的Position是2，所以送出一筆買進2張的委託，
假設刪除委託後發現這一筆委託已經成交了，此時使用者的實際成交部位是1，所以送出一筆買進1張的委託，
綜合上述的邏輯可以歸納出XS執行交易指令的邏輯：
當收到交易指令時，會檢查目前是否有尚未完成成交的委託，如果沒有的話，則依照目前部位與新的部位的差異，送出一筆買進或是賣出的委託，
如果此時還有尚未完成成交的委託的話，則先刪除委託，確認成交的狀態，然後再依照目前成交部位與新的部位的差異，送出一筆買進或是賣出的委託，
至多只會保留一筆尚未完成成交的委託
這樣子的執行邏輯可以應用在追價的情境，例如以下的腳本範例
if Position = 0 and entry_condition then begin
end;
5
6
if Position = 1 and Filled = 0 and CurrentBar - value1 >= 2 then begin
end;
策略初始部位
在先前的範例內，我們提到策略一開始執行時部位預設是從0開始。可是在以下的一些應用情境內，我們會希望策略一開始執行的部位不是0。例如：
我們使用的是一個波段的策略，部位持有的期間可能會超過1日。如果依照波段的計算方式的話，目前這個時間點可能是處在已經進場的階段，此時希望策略一開始的部位是1，而不是0，
我們希望使用這個策略來幫我的庫存進行平倉或是加碼的動作，所以我希望策略一開始的部位就是我的庫存張數
針對這些應用情境，XS自動交易提供了以下的設定方式：
使用歷史資料來模擬計算策略的部位
使用者可以在策略設定內啟動計算策略部位的功能，同時指定策略部位計算的區間(指定日期起點，或是天期)，啟動之後系統就會讀取商品的歷史資料，使用這些歷史資料來執行策略，模擬策略在這段時間的交易部位。
詳細說明請參考「自動交易策略設定」內的「策略部位計算功能」
使用交易帳號的庫存來設定策略的部位
使用者可以在指定策略的交易帳號後，利用帳號的庫存資料來設定策略的部位。可以讓策略的部位與帳號的庫存一模一樣，也可以指定策略的部位是部分庫存。
詳細說明請參考「自動交易策略設定」內的「交易帳號庫存部位整合」
以上是 SetPosition 的說明，大家看過後，若想在進一步了解自動交易功能，可以至以下的官網文章查看詳細的介紹，感謝大家的聆聽，預祝大家投資順心，謝謝：
自動交易的基本觀念
如何建立自動交易策略
自動交易策略參數總覽
自動交易中心操作介紹

---

### Sell

Sell(多單減碼數量)

**說明:**

交易函數\nSell(多單減碼數量，委託價格)\nSell(多單減碼數量，label:="指令標記")\nSell(多單減碼數量，委託價格，label:="指令標記")\nSell函數的第一個參數是減碼部位，必須是一個正整數。第二個參數是此次交易的委託價格，第二個參數如果不傳的話則會使用策略的預設賣出價格。\n與SetPosition一樣，也可以透過label函數傳入指令標記。

**範例:**

```xs
Sell(1);
Sell(1, Close);
Sell(1, MARKET);
Sell(1, label:="出場1張");
```

**注意事項:**

> Sell指令只有在目前Position > 0時才會有作用。如果Sell的減碼數量大於目前Position的話，則Position會改成0，也就是說Sell函數不會把目標部位變成空頭(Position < 0)。
> Sell(0)是一個特殊用法，如果此時的部位大於0的話，Sell(0)的作用是把部位變成0，如果此時的部位小於0的話，則Sell(0)沒有任何作用。
> 以下是Sell(N)的執行邏輯：
> if Position > 0 then
> 2 if N = 0 then
> 3 SetPosition(0) { N=0是特殊用法，把多單部位全部平倉 }
> 4 else
> 5 SetPosition(maxlist(Position - N, 0)); { 從Position(正數)減少N張，最終數字不會小於0 }

---

### Position

```xs
Value1 = Position
```

**說明:**

交易函數\nPosition是一個整數，可以大於0、等於0、也可以小於0。從自動交易腳本內，透過呼叫交易指令，例如SetPosition、Buy、Sell，可以改變Position的數值，當數值變大時，代表要執行買進的動作，當數值變小時則代表要執行賣出的動作。\n交易腳本在每一次執行(洗價)之前系統會決定Position的數值，接下來的執行過程內，不管有沒有呼叫交易指令，Position的數值都不會改變。等到執行完成之後，系統會決定要執行哪一個交易指令，之後Position的數值就會更動，同時系統也會決定如何送出委託來達到這個預期的部位。\nPosition跟Close、Value1等內建的變數一樣，都是一個數值序列。Position或是Position[0]代表的是目前這一根bar的數值。Position[1]則是上一根bar執行時的部位數值。要特別注意的是如果在一根bar內透過逐筆洗價執行了多次交易指令的話，Position的數值會在每一次洗價之後就會異動，也就是說Position是一個intrabarpersist的變數。\n請參考SetPosition語法內關於Position異動的時機點的相關說明。

---

### Market

```xs
setposition(1, Market)
```

**說明:**

交易函數

---

### IsMarketPrice

```xs
Condition1 = IsMarketPrice(value1)
```

**說明:**

交易函數

**範例:**

```xs
if IsMarketPrice(q_BestBid1) then setposition(1);
```

2{ 委買最高價格是市價，表示必須送出市價買進才有機會買到 }

```xs
if IsMarketPrice(q_BestAsk1) then setposition(0);
```

2{ 委賣最低價格是市價，表示必須送出市價賣出才有機會平倉 }

---

### IsListedSymbol

**說明:**

交易函數\n若為策略設定的執行商品則回傳 True。\n舉例來說，假設策略為延續前次執行並勾選自動執行有部位的商品，執行商品設定為指定選股法。\n昨日選股法篩選出了2303.TW並買進了一張，今日策略啟動時，選股法篩選出了 2882.TW，因此策略在今日會執行 2303.TW 和 2882.TW。\nIsListedSymbol 在 2303.TW時會回傳False，在 2882.TW 則是True。

---

### FilledRecordTimeMS

```xs
Value1 = FilledRecordTimeMS(idx)
```

**說明:**

交易函數\n回傳一個最多9位的數字，例如103025.123，代表10點30分25秒123毫秒。

---

### FilledRecordTime

```xs
Value1 = FilledRecordTime(idx)
```

**說明:**

交易函數\n回傳一個最多6位的數字，例如103025，代表10點30分25秒。

---

### FilledRecordQty

```xs
Value1 = FilledRecordQty(idx)
```

**說明:**

交易函數\n不管這一筆成交是買進或是賣出，FilledRecordQty回傳的數值都是大於0的數字。如果需要判斷是買進或是賣出，請使用FilledRecordBS函數。

---

### FilledRecordPrice

```xs
Value1 = FilledRecordPrice(idx)
```

**說明:**

交易函數\n不管這一筆成交是買進或是賣出，FilledRecordPrice回傳的數值都是大於0的數字。如果需要判斷是買進或是賣出，請使用FilledRecordBS函數。

---

### FilledRecordIsRealtime

```xs
Value1 = FilledRecordIsRealtime(idx)
```

**說明:**

交易函數\n如果策略啟動了策略部位計算功能的話，在執行過程內系統會使用歷史資料來模擬策略的交易狀態。\n如果要判斷某一筆成交紀錄是發生在策略部位計算區間或是發生在即時K棒區間的話，可以透過FilledRecordIsRealtime這個函數。發生在即時K棒區間的成交紀錄會回傳1，發生在策略部位計算區間的則回傳0。\n如果策略是用回測方式執行的話，則回傳0 (相當於策略部位計算區間)。

---

### FilledRecordDate

```xs
Value1 = FilledRecordDate(idx)
```

**說明:**

交易函數\n回傳一個8位的數字，例如20200110，代表2020年1月10日。

---

### FilledRecordCount

```xs
Value1 = FilledRecordCount
```

**說明:**

交易函數

**範例:**

```xs
var: idx(0);
value1 = FilledRecordDate(idx);   { 成交日期 }
value2 = FilledRecordTime(idx);   { 成交時間 }
value3 = FilledRecordPrice(idx);   { 成交價格 }
value4 = FilledRecordQty(idx);   { 成交數量 }
```

for idx = 1 to FilledRecordCount begin
7 value5 = FilledRecordBS(idx); { 成交方向: 買進或是賣出 }
8 value6 = FilledRecordIsRealtime(idx); { 是否是在即時區間成交 }
end;

---

### FilledRecordBS

```xs
Value1 = FilledRecordBS(idx)
```

**說明:**

交易函數\n如果這一筆成交紀錄是買進的話，則回傳1，如果是賣出的話則回傳-1。

---

### FilledEntryTimeMS

**說明:**

交易函數\n取得部位建立時間(精準到毫秒)。\n時間格式是一個9碼的數字，例如如果是上午的11點30分00秒500毫秒，則回傳113000.500。

---

### FilledEntryTime

**說明:**

交易函數\n取得部位建立時間。\n時間格式是一個6碼的數字，例如如果是上午的11點30分00秒，則回傳113000。

---

### FilledEntryDate

**說明:**

交易函數\n取得部位建立日期。\n日期格式是一個8碼的數字，例如如果是2015年6月1日，則回傳20150601。

---

### FilledAvgPrice

```xs
Value1 = FilledAvgPrice
```

**說明:**

交易函數

**範例:**

```xs
if Close >= FilledAvgPrice * 1.02 then SetPosition(0);
if Close <= FilledAvgPrice * 0.98 then SetPosition(0);
```

if Filled > 0 then begin
end;
未平倉成本計算邏輯
腳本執行過程內，系統會紀錄每一筆成交紀錄，依照成交時間排序，然後依照這些成交紀錄的成交價格/數量，採用先進先出的方式計算商品的未平倉成本。

在第2筆成交時，Filled = 2，FilledAvgPrice = (100 + 102) / 2 = 101。
假設以下三筆成交記錄, 依照時間順序:
第1筆成交：買進1張，100元，
第2筆成交：買進1張，102元，
第3筆成交：賣出1張，101元
在第1筆成交時，Filled = 1，FilledAvgPrice = 100。
在第3筆成交時，Filled = 1，依照先進先出的沖銷順序， 第3筆賣出1張的成交會沖銷掉第1筆買進1張成交，所以未平倉數量剩下第2筆的買進1張, FilledAvgPrice = 102。
請注意：上面這個計算方式跟把所有成本加總後來除是不一樣的((100 + 102 - 101) / 1 = 101)：全部加總後的平均數值會涵蓋已實現損益。

在第2筆成交時，Filled = 4，FilledAvgPrice = (100 _ 2 + 101 _ 2) / 4 = 100.5。
在第3筆成交時，Filled = 6，FilledAvgPrice = (100 _ 2 + 101 _ 2 + 102 * 2) / 6 = 101。
在第4筆成交時，Filled = 3，依照先進先出的沖銷原則，第4筆的賣出3張分別沖掉了第1筆的買進2張，以及第2筆的買進1張，所以剩餘的買進成交是第2筆買進1張，101元，以及第3筆的買進2張，102元，FilledAvgPrice = (101*1 + 102 \* 2) / 3 = 101.66666。
第1筆成交：買進2張，100元，
第2筆成交：買進2張，101元，
第3筆成交：買進2張，102元，
第4筆成交：賣出3張，101元
在第1筆成交時，Filled = 2，FilledAvgPrice = 100。
如果策略在設定時指定要採用交易帳號的庫存部位的話，此時系統就會依照策略的設定修改未平倉成本，之後收到成交之後再依照先進先出的方式調整數值。

第1筆成交時，Filled = 3，FilledAvgPrice = (100 _ 2 + 102 _ 1) / 3 = 100.66666。
第2筆成交時，Filled = 2，依照先進先出的沖銷方式，這一筆賣出1張會沖銷掉策略指定部位其中1張，所以剩餘的數量是策略指定部位的1張，100元，跟第1筆成交1張的102元，FilledAvgPrice = (100 _ 1 + 102 _ 1) / 2 = 101。
策略設定時指定策略部位：部位=2張，成本=100元，
第1筆成交：買進1張，102元，
第2筆成交：賣出1張，101元，
在策略指定策略部位時，Filled = 2，FilledAvgPrice = 100。
請注意：未平倉成本不包含交易成本，所以使用者如果要估算未平倉損益時，可以在腳本內利用[ＦFilledRecordCount等函數取得每一筆成交紀錄，然後再自行計算。

---

### FilledAtBroker

**說明:**

交易函數\n該數值會隨策略設定的現股、資券而取得該類別的庫存數量。\nFilledAtBroker 和 Filled 可能會不同，且策略運作時同一個券商帳號內發生的交易都會影響到此函數的回傳數值。\n更詳細的說明可參考 如何使用函數取得商品的實際庫存數量 此篇文章。

---

### Filled

```xs
Value1 = Filled
```

**說明:**

交易函數\nFilled是一個整數，可以大於0、等於0、也可以小於0。從自動交易腳本內，透過呼叫交易指令，例如SetPosition、Buy、Sell，來執行交易的動作。系統執行交易指令之後，Position的數值會跟著異動，如果個交易指令成交之後，則Filled的數值也會跟著異動。\n舉例而言，假如腳本開始執行時Position是0，Filled也是0。\n當腳本呼叫SetPosition(1)之後，系統會送出一筆買進1張的委託，Position會變成1，此時如果尚未成交的話，Filled還是0，等到這一筆委託單成交之後，Filled就會變成1。\n如果委託單部分成交的話，則Filled也會反應部分成交的狀態。例如腳本呼叫SetPosition(2)之後，系統會送出一筆買進2張的委託，Position會變成2。此時如果尚未成交的話，Filled是0，如果這一筆委託單成交1張的話，Filled會變成１，等到這一筆委託單完成成交時，Filled就會變成2。\n交易腳本在每一次執行(洗價)之前系統會決定Filled的數值，接下來的執行過程內，不管有沒有收到成交回報，Filled的數值都不會改變。\n如同Position，Filled也是一個數值序列。Filled或是Filled[0]代表的是目前這一根bar的成交部位數值。Filled[1]則是上一根bar執行時的成交部位數值。如果開啟逐筆洗價的話，每一根bar內可能會執行多次，Filled的數值則會在每一次洗價之前就會依照當時的成交狀態更新。\n透過比對Position跟Filled，腳本可以判斷目前腳本的成交情形，進而做不同的後續處理：

**範例:**

```xs
if Position = 0 and entry_condition then SetPosition(1);
if Close >= FilledAvgPrice * 1.02 then SetPosition(0);
if Close <= FilledAvgPrice * 0.98 then SetPosition(0);
```

if Filled = 1 then begin
end;
在這個範例內腳本透過判斷Filled是否是1來決定是否已經成交。一旦成交之後，則透過比對目前價格與未平倉成本FilledAvgPrice是否達到停損停利的範圍來決定是否要進行平倉。

```xs
if Position = 0 and entry_condition then SetPosition(1);
if TrueAll(Position <> Filled, 3) then SetPosition(1, MARKET);
```

在這個範例內腳本透過比對Position跟Filled的差異來決定是否尚未成交。如果Position跟Filled連續3根bar都不一樣的話，那麼就改用市價買進。

---

### DefaultSellPrice

```xs
Value1 = DefaultSellPrice
```

**說明:**

交易函數\n市價 (如果是期貨的話，則是範圍市價)\n觸發價 +/- 檔數\n如果策略指定預設賣出價格為市價的話，DefaultSellPrice會回傳商品的跌停價(如果商品沒有漲停跌停價的話，則回傳洗價K棒的收盤價)。如果指定的是觸發價 +/- 檔數的話，則回傳依照洗價K棒的收盤價加減檔數後的價格。與AddSpread一樣，加減檔數後的數值不會超過商品的漲跌停限制。\n使用者可以利用這個函數，取得交易指令的實際委託價格，可以應用於，例如利用金額來換算委託數量。\ninput: ordersize*w(10, "每筆交易金額(萬)");\n2\n3\n4{ 換算委託張數 }\nvalue1 = (ordersize_w * 10000) / (DefaultSellPrice \_ 1000);\nSetPosition(-1 \* value1);

---

### DefaultBuyPrice

```xs
Value1 = DefaultBuyPrice
```

**說明:**

交易函數\n市價 (如果是期貨的話，則是範圍市價)\n觸發價 +/- 檔數\n如果策略指定預設買進價格為市價的話，DefaultBuyPrice會回傳商品的漲停價(如果商品沒有漲停跌停價的話，則回傳洗價K棒的收盤價)。如果指定的是觸發價 +/- 檔數的話，則依照回傳洗價K棒的收盤價加減檔數後的價格。與AddSpread一樣，加減檔數後的數值不會超過商品的漲跌停限制。\n使用者可以利用這個函數，取得交易指令的實際委託價格，可以應用於，例如利用金額來換算委託數量。\ninput: ordersize*w(10, "每筆交易金額(萬)");\n2\n3\n4{ 換算委託張數 }\nvalue1 = (ordersize_w * 10000) / (DefaultBuyPrice \_ 1000);\nSetPosition(value1);

---

### Cover

Cover(空單回補數量)

**說明:**

交易函數\nCover(空單回補數量，委託價格)\nCover(空單回補數量，label:="指令標記")\nCover(空單回補數量，委託價格, label:="指令標記")\nCover函數的第一個參數是回補部位，必須是一個正整數。第二個參數是此次交易的委託價格，第二個參數如果不傳的話則會使用策略的預設買進價格。\n與SetPosition一樣，也可以透過label函數傳入指令標記。

**範例:**

```xs
Cover(1);
Cover(1, Close);
Cover(1, MARKET);
Cover(1, label:="回補1張");
```

**注意事項:**

> Cover指令只有在目前Position < 0時才會有作用。如果Cover的回補數量超過目前空單數量的話，則Position會改成0，也就是說Cover函數不會把目標部位變成多頭(Position > 0)。
> Cover(0)是一個特殊用法，如果此時的部位小於0的話，Cover(0)的作用是把部位變成0，如果此時的部位大於0的話，則Cover(0)沒有任何作用。
> 以下是Cover(N)的執行邏輯：
> if Position < 0 then
> 2 if N = 0 then
> 3 SetPosition(0) { N=0是特殊用法，把空單部位全部回補 }
> 4 else
> 5 SetPosition(minlist(Position + N, 0)); { 從Position(負數)增加N張，最終數字不會大於0 }

---

### CancelAllOrders

```xs
CancelAllOrders()
```

**說明:**

交易函數\nCancelAllOrders(label:="指令標記")\n請參考：CancelAllOrders語法說明 文章

---

### Buy

Buy(多單加碼數量)

**說明:**

交易函數\nBuy(多單加碼數量，委託價格)\nBuy(多單加碼數量，label:="指令標記")\nBuy(多單加碼數量，委託價格，label:="指令標記")\nBuy函數的第一個參數是加碼部位，必須是一個正整數。第二個參數是此次交易的委託價格，第二個參數如果不傳的話則會使用策略的預設買進價格。\n與SetPosition一樣，也可以透過label函數傳入指令標記。

**範例:**

```xs
Buy(1);
Buy(1, Close);
Buy(1, MARKET);
Buy(1, label:="買進1張");
```

**注意事項:**

> 當目前的Position < 0時，執行Buy指令時會先把空頭部位全部平倉(部位變成0)，之後再進行加碼的動作。
> Buy(0)是一個特殊用法，如果此時的部位小於0的話，Buy(0)的作用是把部位變成0，如果此時的部位大於0的話，則Buy(0)沒有任何作用。
> 以下是Buy(N)的執行邏輯：
> if Position < 0 then
> 2 SetPosition(N) { 從Position(負數)變成N(正數) }
> else
> 4 SetPosition(Position + N); { 從Position(零或是正數)變成Position+N }

---

### Alert

Alert(字串1)

**說明:**

交易函數\nAlert(字串1, 數值1, ...)\n透過Alert函數，自動交易策略在執行過程內可以產生一筆警示紀錄，達到類似策略雷達警示的提示效果。\n當自動交易策略產生警示時，使用者可以透過以下幾種方式看到警示紀錄：\n自動交易策略中心的執行紀錄畫面：\n自動交易策略中心的商品監控畫面：\n警示提示視窗：\n自動交易中心開啟推播後，可以傳到手機：

---

### AddSpread

Value1 = AddSpread(基礎價格, 檔位)

**說明:**

交易函數\n呼叫時需要傳入兩個參數：第一個參數是基礎價格，第二個參數是加減檔數，如果要加檔數的話請傳入一個大於0的數值，如果要減檔數的話請傳入一個小於0的數值。如果商品有漲跌停限制的話，計算後的數值不會超過漲跌停限制。

**範例:**

```xs
Value1 = AddSpread(Close, 1);  { 收盤價+1檔 }
Value2 = AddSpread(Low, -1); { 最低價-1檔 }
```

這個函數主要應用在交易的情境，如果目前的執行商品並沒有檔位限制的話(例如加權指數)，則系統會以商品的報價跳動點來當成檔位的計算依據(例如加權指數的話則每一檔是0.01)。

---

### Array_Sum

**說明:**

加總數值 = Array_Sum(陣列, 開始位置, 結束位置)\n陣列函數\n舉例:\nArray: arr[5](0); // 宣告arrA是一個有5個元素的陣列，初始值都是0\n2\n3\narr[1] = 1; arr[2] = 2; arr[3] = 3; arr[4] = 4; arr[5] = 5;\n5\n6\nValue1 = Array_Sum(arr, 1, 5); // Value1 = 15 (1 + 2 + 3 + 4 + 5)\nValue2 = Array_Sum(arr, 1, 3); // Value2 = 6 (1 + 2 + 3)\n上例內Value1是arr這個陣列從第一個元素加總到第五個元素的數值，也就是等於arr[1] + arr[2] + arr[3] + arr[4] + arr[5] = 15，而Value2則是從第一個元素到第三個元素的加總 (1 + 2 + 3 = 6)。

---

### Array_Sort2d

**說明:**

Array_Sort2d(陣列，執行排序的開始位置，執行排序的結束位置，排序的比較欄位，排序的順序)\n陣列函數\n排序的順序如果是true的話則由小排到大，如果是false的話則由大排到小\n第一個參數是要排序的二維陣列變數，\n第二個參數是這個陣列內執行排序的開始位置。位置從1開始，\n第三個參數是這個陣列內執行排序的結束位置。位置從1開始，\n第四個參數是決定排序的基準位置。位置從1開始，\n第五個參數決定排序的順序，如果是true的話，則由小排到大，如果是false的話，則由大排到小，\n執行後這個陣列內指定範圍內元素將會依照指定的排序方式重新排列。\n舉例:\nArray: datum[15, 6](0); // 宣告datum是一個有15（列）6（行）的二維陣列，初始值都是0\nvar:i(0);\n3\n4\nfor i = 1 to 15 begin\n6 datum[i, 1] = time[i];\n7 datum[i, 2] = open[i];\n8 datum[i, 3] = high[i];\n9 datum[i, 4] = low[i];\n10 datum[i, 5] = close[i];\n11 datum[i, 6] = volume[i];\nend;\n13\narray_sort2d(datum, 1, 15, 6, true); //datum = [最小volume, 次小volume, ... 最大volume]\narray_sort2d(datum, 1, 15, 6, false); //datum = [最大volume, 次大volume, ... 最小volume]\n上例內第一次呼叫array_sort2d時，傳入的順序是true，所以會從小排到大，執行後datum的內容以第六行排序，排序後同列的資料會以第六行為基準一起移動。\n第二次呼叫array_sort2d時，傳入的順序是false，所以會從大排到小，執行後datum的內容以第六行排序，排序後同列的資料會以第六行為基準一起移動。

---

### Array_Sort

**說明:**

Array_Sort(陣列，執行排序的開始位置，執行排序的結束位置，排序的順序)\n陣列函數\n排序的順序如果是true的話則由小排到大，如果是false的話則由大排到小\n第一個參數是要排序的陣列變數，\n第二個參數是這個陣列內執行排序的開始位置。位置從1開始，\n第三個參數是這個陣列內執行排序的結束位置。位置從1開始，\n第四個參數決定排序的順序，如果是true的話，則由小排到大，如果是false的話，則由大排到小，\n執行後這個陣列內指定範圍內元素將會依照指定的排序方式重新排列。\n舉例:\nArray: arr[5](0); // 宣告arrA是一個有5個元素的陣列，初始值都是0\n2\n3\narr[1] = 1; arr[2] = 3; arr[3] = 5; arr[4] = 2; arr[5] = 4;\n5\n6\nArray_Sort(arr, 1, 5, true); // arr = [1, 2, 3, 4, 5]\nArray_Sort(arr, 1, 5, false); // arr = [5, 4, 3, 2, 1]\n上例內第一次呼叫Array_Sort時，傳入的順序是true，所以會從小排到大，執行完成後arr的內容變成\n[1, 2, 3, 4, 5]。\n第二次呼叫Array_Sort時，傳入的順序是false，所以會從大排到小，執行完成後arr的內容變成[5, 4, 3, 2, 1]。

---

### Array_SetValRange

**說明:**

Array_SetValRange(陣列，開始位置，結束位置，新設定的數值)\n陣列函數\n第一個參數是陣列變數，\n第二個參數是設定數值的開始位置，位置從1開始，\n第三個參數是設定數值的結束位置，位置從1開始，\n第四個參數是要設定的數值\n執行時，從這個陣列的開始位置一直到結束位置的每個元素的數值都會被改成為新設定的數值。\nArray: arr[5](0); // 宣告arrA是一個有5個元素的陣列，初始值都是0\n2\n3\narr[1] = 1; arr[2] = 2; arr[3] = 3; arr[4] = 4; arr[5] = 5;\n5\n6\nArray_SetValRange(arr, 1, 3, 0); // arr[1] = 0, arr[2] = 0, arr[3] = 0, arr[4] = 4, arr[5] = 5\n在上例內呼叫Array_SetValRange，位置從1到3，新設定的數值為0。所以執行結束後arr[1], arr[2], arr[3]的數值都會被改成0，而arr[4]跟arr[5]的值則維持不變。

---

### Array_SetMaxIndex

Array_SetMaxIndex(陣列，陣列內的元素個數)

**說明:**

陣列函數\n僅支援一維陣列\nVar: Count(0);\nArray: NumArray[](0);\n3\n4\nIf High > Highest(High,20)[1] Then Count = Count + 1;\n6\n7\nArray_SetMaxIndex(NumArray, Count);\nNumArray[Count] = High;\n在上述範例內，我們希望可以儲存破20期新高的所有價格。由於執行過程內可能會發生多次創新高的情形，所以我們使用陣列來儲存這些創新高的價位。又由於無法知道創新高的出現次數，所以程式使用動態陣列來儲存這些價格。在上面的範例內，Count就是目前已經創新高的個數，而當又出現創新高的情形時，程式就使用Array_SetMaxIndex來擴充陣列的大小。

---

### Array_GetType

資料類型 = Array_GetType(陣列)

**說明:**

陣列函數\n回傳數值如果是2，表示為邏輯值True/False陣列，如果是3，表示為字串陣列，如果是7，則表示為數值陣列\nArray: arrNumber[5](0);\nArray: arrString[5]("");\nArray: arrBoolean[5](true);\n4\n5\nValue1 = Array_GetType(arrNumber); // Value1 = 7\nValue2 = Array_GetType(arrString); // Value2 = 3\nValue3 = Array_GetType(arrBoolean); // Value3 = 2

---

### Array_GetMaxIndex

元素個數 = Array_GetMaxIndex(陣列變數)

**說明:**

陣列函數\nArray: arrA[5](0); // 宣告arrA是一個有5個元素的陣列，初始值都是0\n2\n3\nValue1 = Array_GetMaxIndex(arrA); // Value1 = 5\n我們可以利用這個函數來動態取得陣列的大小，讓程式更容易維護：\nArray: arrA[5](0); // 宣告arrA是一個有5個元素的陣列，初始值都是0\nVar: I(0);\n3\n4\nFor I = 1 To Array_GetMaxIndex(arrA)\nBegin\n7 arrA[I] = arrA[I] + 1;\nEnd;\n在上述範例內雖然我們已經知道arrA的大小為5，可是我們還是可以利用 Array_GetMaxIndex 來取得 arrA 的大小。未來程式如果有需要調整arrA的大小時，程式內迴圈的程式碼可以不需要修改，方便程式的維護。

---

### Array_Copy

**說明:**

Array_Copy(陣列A, 陣列A開始複製的位置, 陣列B, 陣列B開始儲存複製資料的位置, 複製的個數)\n陣列函數\n如果成功則回傳0，否則回傳小於0的錯誤碼\nArray: arrA[5](0); // 宣告arrA是一個有5個元素的陣列，初始值都是0\nArray: arrB[5](0); // 宣告arrB是一個有5個元素的陣列，初始值都是0\nArray: arrC[5](0); // 宣告arrC是一個有5個元素的陣列，初始值都是0\n4\n5\narrA[1] = 1; arrA[2] = 2; arrA[3] = 3; arrA[4] = 4; arrA[5] = 5;\n7\n8\nArray_Copy(arrA, 1, arrB, 1, 5); // 執行後 arrB = [1, 2, 3, 4, 5]\nArray_Copy(arrA, 1, arrC, 2, 3); // 執行後 arrC = [0, 1, 2, 3, 0]\n第一個範例內，指定從arrA的第一個位置開始複製到arrB的第一個位置，總共複製5個元素，所以執行完成後arrB的內容會是[1, 2, 3, 4, 5]，剛好跟arrA的數值完全一樣。\n第二個範例內，指定從arrA的第一個位置開始複製到arrC的第二個位置，總共複製3個元素，也就是說:\narrA[1] 複製到 arrC[2]\narrA[2] 複製到 arrC[3]\narrA[3] 複製到 arrC[4]\n所以執行完成後 arrC的內容會是 [0, 1, 2, 3, 0]，注意到arrC的初始值為0，所以沒有被複製到的位置還是保留初始值。

---

---

### UserID

```xs
Print("目前使用者代碼", UserID);
```

**說明:**

欄位函數\n回傳使用者帳號 = UserID

---### Array_Compare

**說明:**

比較兩個陣列的元素內容。

**語法:**

```xs
Value1 = Array_Compare(陣列A, 陣列A開始比對的位置, 陣列B, 陣列B開始比對的位置, 比對的個數);
```

**參數:**

- **陣列A**: 第一個要比對的陣列。
- **陣列A開始比對的位置**: 從陣列A的第幾個索引開始比對。
- **陣列B**: 第二個要比對的陣列。
- **陣列B開始比對的位置**: 從陣列B的第幾個索引開始比對。
- **比對的個數**: 要比對的元素數量。

**回傳值:**

- `1`: 陣列A > 陣列B (在第一個不同的位置，陣列A的數值大於陣列B)。
- `-1`: 陣列A < 陣列B (在第一個不同的位置，陣列A的數值小於陣列B)。
- `0`: 兩個陣列在指定範圍內完全相同。
- `-2`: 發生錯誤 (例如比對範圍超過陣列大小)。

**範例:**

```xs
Array: arrA[5](0);
Array: arrB[5](0);
Array: arrC[5](0);

arrA[1] = 0; arrA[2] = 10; arrA[3] = 20; arrA[4] = 30; arrA[5] = 40;
arrB[1] = 0; arrB[2] = 0; arrB[3] = 10; arrB[4] = 20; arrB[5] = 30;
arrC[1] = 0; arrC[2] = 20; arrC[3] = 30; arrC[4] = 40; arrC[5] = 50;

Value1 = Array_Compare(arrA, 1, arrB, 1, 3); // Return 1 (arrA[2]=10 > arrB[2]=0)
Value2 = Array_Compare(arrA, 1, arrC, 1, 3); // Return -1 (arrA[2]=10 < arrC[2]=20)
Value3 = Array_Compare(arrA, 1, arrB, 2, 3); // Return 0 (0,10,20 vs 0,10,20)
Value4 = Array_Compare(arrA, 1, arrB, 1, 8); // Return -2 (Out of bounds)
```

### SymbolName

**說明:**

欄位函數\n回傳名稱 = SymbolName\n通常可以在Print函數內使用這個函數，在列印的內容內把商品名稱印出來。

**範例:**

```xs
Print("商品名稱", SymbolName);
```

請參考Symbol函數。

---

### Symbol

**說明:**

欄位函數\n回傳代碼 = Symbol\n如果有多個商品同時執行同一個腳本時(例如策略雷達)，可以利用這個函數來判斷目前執行的商品而做不同的處理，也可以利用這個函數搭配Print函數來輸出目前執行的商品代碼。

---

### GetSymbolInfo

**說明:**

回傳最新的商品資訊 = GetSymbolInfo("商品資訊欄位名稱")\n欄位函數\nGetSymbolInfo函數可以傳入商品資訊欄位的中文或是英文名稱，以下是一個簡單的範例：\nvar:aa(""),aaa("");\naa = GetSymbolInfo("交易所");//回傳最新的實際掛牌交易所（支援台股、權證與可轉債）\naaa= GetSymbolInfo("exchange");//回傳最新的實際掛牌交易所（支援台股、權證與可轉債）\nGetSymbolInfo可以使用的商品資訊欄位為：\n交易所：回傳商品掛牌的交易所。格式是字串。支援台股、台(權證)、台(可轉債)、台(特別股)、美(股票)\n即將處置結束股：回傳當日是否是處置期間的最後一日。格式是布林值。支援台股、台(權證)、台(可轉債)\n近期處置結束股：回傳商品是否在過去7日內剛結束處置。格式是布林值。支援台股、台(權證)、台(可轉債)\n累計異常注意股：回傳商品當日是否為累計異常注意股。格式是布林值。支援台股、台(權證)、台(可轉債)、台(特別股)\n處置股：回傳當日是否為處置股(警示股)。格式是布林值。支援台股、台(權證)、台(可轉債)、台(特別股)\n注意股：回傳當日是否為注意股。格式是布林值。支援台股、台(權證)、台(可轉債)、台(特別股)\n買賣現沖：回傳當日是否可以現股當沖。格式是布林值。支援台股。\n先買現沖：回傳當日是否可以現股先買後賣。格式是布林值。支援台股。\n可放空：回傳當日是否可以融券放空。格式是布林值。支援台股。\n平可空：回傳當日是否可以在平盤以下融券放空。格式是布林值。支援台股。\n期貨近月：回傳商品的相關期貨近月商品代碼。格式是字串。例如FITXN01.TF、FICDF01.TF。支援台股、期貨。\n期貨遠月：回傳商品的相關期貨遠月商品代碼。格式是字串。例如FITXN02.TF、FICDF02.TF。支援台股、期貨。\n期貨次遠月：回傳商品的相關期貨次遠月商品代碼。格式是字串。例如FITXN03.TF。支援台股、期貨。\n有認購權證：回傳商品是否有發行認購型權證商品。格式是布林值。支援台股、大盤。\n有認售權證：回傳商品是否有發行認售型權證商品。格式是布林值。支援台股、大盤。\n有牛證：回傳商品是否有發行牛證權證商品。格式是布林值。支援台股、大盤。\n有熊證：回傳商品是否有發行熊證權證商品。格式是布林值。支援台股、大盤。\n有期貨：回傳商品是否有衍生的期貨商品。格式是布林值。支援台股、大盤。\n有選擇權：回傳商品是否有衍生的選擇權商品。格式是布林值。支援台股、大盤。\n有可轉債：回傳商品是否有發行可轉債(CB)商品。格式是布林值。支援台股。\n執行比例：回傳權證商品的執行比例。格式是數值。台(權證)\n履約價：回傳選擇權商品或是權證商品的履約價。格式是數值。台(權證)、選擇權。\n買賣權：回傳選擇權商品或是權證商品的買賣權別。格式是字串(CALL/PUT)。台(權證)、選擇權。\n到期日：回傳商品的到期日。欄位格式為西元年月日，例如20221101。支援台(權證)、台(可轉債)、期貨、選擇權、美(特別股)\n標的物：回傳衍生性商品所對應的標的商品代碼。格式是字串。支援台(權證)、台(可轉債)、台(特別股)、期貨、選擇權。\n轉換價格：回傳可轉債商品(CB)最新的轉換價格。格式是數值。支援台(可轉債)\n可轉換日：回傳可轉債商品(CB)的可轉換日期。欄位格式為西元年月日，例如20221101。台(可轉債)\n票面利率：回傳可轉債商品(CB)或是特別股的票面利率。格式是數值。台(可轉債)、台(特別股)、美(特別股)\n擔保品：回傳可轉換商品(CB)是否有擔保。格式是布林值。台(可轉債)\n發行張數：回傳可轉債商品(CB)的發行張數。台(可轉債)\n交易幣別：回傳商品的交易幣別。格式是字串，例如"台幣"，"美元"等。支援台股。\n交易單位：回傳商品的交易單位。格式是數值。支援台股。\n面額：回傳股票每一股的面額(是多少元)。格式是數值。支援台股。\n面額幣別：回傳股票的發行幣別。格式是字串，例如"台幣"，"美元"等。支援台股。\nETD：是否是交易所交易債券(ETD)。格式是布林值。支援美(特別股)\n第一個回購日：回傳美股特別股的第一個回購日期。欄位格式為西元年月日，例如20221101。支援美(特別股)

---

### GetSymbolFieldDate

欄位資料日期 = GetSymbolFieldDate("ID", "欄位名稱")

**說明:**

欄位函數\n欄位資料日期 = GetSymbolFieldDate("ID", "欄位名稱","頻率")\n傳入欄位名稱，跟指定的欄位頻率。如果不傳頻率的話，則使用目前執行頻率。回傳欄位的資料日期，格式為YYYYMMDD 8碼數字。\nGetSymbolFieldDate函數可以傳入三個參數：\n第一個參數是商品代碼，\n第二個參數是欄位的中文或是英文名稱，\n第三個參數則是欄位的頻率，如果省略這個參數的話，則會依照目前腳本執行的頻率來取得對應的資料\n以下是一個簡單的範例（選股腳本）：\nGetSymbolFieldDate("2330.TW","月營收");\nGetSymbolFieldDate("2330.TW","月營收","M");\nret=1;\n詳細的語法說明可以參考 GetFieldDate函數。

---

### GetSymbolField

欄位數值 = GetSymbolField("ID", "欄位名稱")

**說明:**

欄位函數\n欄位數值 = GetSymbolField("ID", "欄位名稱","頻率")\n欄位數值 = GetSymbolField("ID", "欄位名稱", "頻率", 是否為還原值)\n傳入欄位名稱，跟指定的欄位頻率。如果不傳頻率的話，則讀取目前執行頻率的對應欄位\nGetSymbolField函數可以傳入三個參數：\n第一個參數是商品代碼，\n第二個參數是欄位的中文或是英文名稱，\n第三個參數則是欄位的頻率，如果省略這個參數的話，則會依照目前腳本執行的頻率來取得對應的資料\n第四個參數則為「是否為還原值」運用 Adjusted參數 來設定要讀取的是原始資料，還是還原資料。\n當你點選XS編輯器內的編輯選單/插入欄位選項，或是按快捷鍵F7，利用「插入欄位」畫面加入欄位的同時，如果在商品欄位填入有效商品時，系統會自動插入GetSymbolField函數（沒填商品時是插入GetField函數）。插入欄位畫面沒有還原分鐘的選項，如果使用者需要取的還原分鐘相關資料，請直接撰寫在腳本中。\n以下是一個簡單的範例：\nValue1 = getsymbolField("1101.TW", "收盤價");　// value1 為取得目前腳本執行頻率的台泥(1101)收盤價。\nValue2 = getsymbolField("1101.TW", "收盤價", "1");　// value2 為取得原始1分鐘頻率的台泥(1101)收盤價。\nValue3 = getsymbolField("1101.TW", "收盤價", "1", Adjusted:=true);　// value3 為取得還原1分鐘頻率的台泥(1101)收盤價。\n另外在「插入欄位」畫面的商品下拉式選單有「標的商品、期貨近/遠/次遠月」選項，選擇後按下插入，系統會自動插入GetSymbolField取得標的商品相關欄位的語法在XS編輯器中，編譯成功後加入相關應用，即可取得商品的「標的商品、期貨近/遠/次遠月」相關欄位數據。\n以下是 GetSymbolField「標的商品、期貨近/遠/次遠月」範例：\n//假設以下情境：\n2//1. 執行商品：台積電期近月(FICDF*1.TF)\n3//2. 執行時間：08月24日\n4//3. 加入雷達，進行盤中雷達實際測試。\n5\n6\nif getinfo("IsRealTime") <> 1 then return;\n8//只跑在即時資料區間段，原因是跑 GetSymbolField("Future*2", "收盤價") 會取得遠月的收盤價，但遠月歷史資料期間短，故僅跑在即時資料區間段。\n9\n10\nvalue1 = GetSymbolField("Underlying", "收盤價");\n12//value1是台積電期近月之標的商品收盤價；\n13//也就是台積電(2330.TW)收盤價。\n14\n15\nvalue2 = GetSymbolField("Future*1", "收盤價");\n17//value2是台積電期近月之期貨近月收盤價；\n18//在此範例就是台積電期09月(FICDF09.TF)收盤價。\n19\n20\nvalue3 = GetSymbolField("Future*2", "收盤價");\n22//value3是台積電期近月之期貨遠月收盤價。\n23//在此範例就是台積電期10月(FICDF10.TF)收盤價。\n詳細的語法說明可以參考 GetField函數。

---

### GetQuote

報價欄位數值 = GetQuote(欄位名稱)

**說明:**

欄位函數\n報價欄位數值 = q*欄位英文名稱\n報價欄位不支援回測功能\n即時報價欄位涵蓋的範圍有:\n由交易所提供的即時報價，如五檔委託價量以及即時成交等資料\n由系統統計的市場行情資訊，如加權指數漲跌家數，當日內外盤量等資料\n商品的最新一期基本資料相關數據，例如發行股數，每股淨值，最新一季的毛利率等\n使用者可以點選XS編輯器內的編輯選單/插入欄位選項，或是按快捷鍵F7，在插入欄位畫面內點選報價標籤，然後就可以搜尋或是瀏覽需要的報價欄位。\n使用者可以在XS編輯器中的功能列按下「欄位」圖示，或是按快捷鍵F7，進入插入欄位視窗後，先選取「報價欄位」標籤頁，再點選欲加入報價欄位的名稱，最後按下「插入」按鈕，就會在XS編輯器中產生 q* 開頭的 GetQuote 報價欄位語法。\n目前即時報價欄位僅能使用在警示與交易類型的腳本。而且由於報價欄位的數值是採用即時更新的方式，只提供最新的數值，無法取得前期值，因此無法使用在回測上，在使用上要注意這個特性。\n以下是一個使用即時報價欄位的範例:\nInput: OpenGap(1);\nInput: Downpercent(1);\n3\n4\nif q*DailyHigh = q_DailyOpen and\n6 q_DailyOpen > q_RefPrice * (1+ OpenGap/100) and\n7 q*Last < q_DailyHigh * (1 - Downpercent/100)\nthen ret=1;\n上面的這個警示腳本內判斷如果當日開在最高(q_DailyHigh = q_DailyOpen)，而且是跳空開出 (q_DailyOpen > q_RefPrice \* (1 + 跳空比例/100)，而目前的價格 q_Last已經回落一定範圍的話則觸發警示。在這裡q_DailyHigh為當日的最高價, q_DailyOpen為當日的開盤價, q_RefPrice為當日的參考價, q_Last為當日的最新價格，這些都是常用的報價欄位。

---

### GetFieldDate

欄位資料日期 = GetFieldDate(欄位名稱)

**說明:**

欄位函數\n欄位資料日期 = GetFieldDate(欄位名稱, 頻率)\n傳入欄位名稱，跟指定的欄位頻率。如果不傳頻率的話，則使用目前執行頻率。回傳欄位的資料日期，格式為YYYYMMDD 8碼數字。\n如果使用者希望知道實際的欄位資料日期的話，則可以使用GetFieldDate這個函數。\nGetFieldDate函數傳入的參數與GetField是一樣的，需要傳入欄位名稱，以及指定的期別。與GetField不同的是，GetField回傳的是這個欄位的數值，而GetFieldDate回傳的則是這個欄位的資料日期。\n由於營收/財報等資料的公佈日期往往落後於目前的日期，所以如果在運算時需要清楚的知道資料的日期的話，則可以使用GetFieldDate這個函數。\n在以下的選股腳本內，我們使用GetFieldDate來判斷最新一期月營收的日期，然後利用這個日期來估計最新一季的獲利:\nVar: mm(0);\n2\n3\nmm = Month(GetFieldDate("月營收","M"));\nif mm=1 or mm=4 or mm=7 or mm=10\nthen value1=GetField("月營收","M") _ 3;\n7\n8\nif mm=2 or mm=5 or mm=8 or mm=11\nthen value1=GetField("月營收","M") _ 2 + GetField("月營收","M")[1];\n11\n12\nif mm=3 or mm=6 or mm=9 or mm=12\nthen value1=GetField("月營收","M")+GetField("月營收","M")[1]+GetField("月營收","M")[2];\n15\n16\n17// 預估獲利(單位=百萬) = 季營收 _ 毛利率 - 營業費用\n18//\nvalue2 = value1 _ GetField("營業毛利率","Q") - GetField("營業費用","Q");\n20\n21\nOutputField1(value1, "預估單季營收(億)");\nOutputField2(value2 / 100, "預估單季本業獲利(億)");\n24\n25\nret = 1;\n當最新一期的月營收的月份是1月/4月/7月/10月時, 我們估算當季的營收為最新這個月的營收 _ 3，如果最新一期的月營收的月份是2月/5月/8月/11月時，因為當季的營收已經公佈了兩個月了，所以我們用當季的第一次營收 ( GetField("月營收", "M")[1] ) 來加上最新這個月的營收 _ 2來當成這一季的估季營收，如果最新一期的月營收的月份是3月/6月/9月/12月的話，則因為當季所有月份的營收都已經公佈了，所以我們就把近三期的月營收加起來。\n計算完當季的估計營收之後，接下來就可以使用最新一期的毛利率等資料來估算獲利了。\n在上面範例內估算營收的邏輯只是一個範例，如果知道了月份之後，也可以利用月營收年成長率來等資料來做其他的推算。

---

### GetField

欄位數值 = GetField("欄位名稱")

**說明:**

欄位函數\n欄位數值 = GetField("欄位名稱", "頻率")\n欄位數值 = GetField("欄位名稱", "頻率", 是否為還原值)\n傳入欄位名稱、指定的欄位頻率與是否為還原值。\n如果不傳頻率的話，則讀取目前執行頻率的對應欄位。\n如果不傳是否為還原值，則讀取原始值資料。\nGetField函數可以傳入三個參數:\n第一個參數是欄位的中文或是英文名稱，\n第二個參數則是欄位的頻率，如果省略這個參數的話，則會依照目前腳本執行的頻率來取得對應的資料\n第三個參數則為「是否為還原值」運用 Adjusted參數 來設定要讀取的是原始資料，還是還原資料。\n以下是一個簡單的範例:\nValue1 = GetField("收盤價");　// value1 為取得目前腳本執行頻率的收盤價。\nValue2 = GetField("收盤價", "1");　// value2 為取得原始1分鐘頻率的收盤價。\nValue3 = GetField("收盤價", "1", Adjusted:=true);　// value3 為取得還原1分鐘頻率的收盤價。\nGetField可以使用的欄位分成兩種類型:\n第一種是資料欄位，支援指標腳本、警示腳本以及交易腳本。\n第二種是選股欄位，支援選股腳本。\n使用者可以點選XS編輯器內的編輯選單/插入欄位選項，或是按快捷鍵F7，進入插入欄位畫面內搜尋或是瀏覽需要的欄位，從插入欄位畫面內也可以找到欄位的說明等資訊。\nGetField欄位除了可以取得某個欄位在目前K棒的數值之外，也可以取得某個欄位的前期值:\nIf Close > Close[1] And\n2 GetField("外資買賣超") > GetField("外資買賣超")[1]\nThen\n4 Ret = 1;\n在上述警示範例內使用GetField("外資買賣超")來讀取外資的買賣超張數。注意到GetField("外資買賣超")[1]的用法：GetField函數的回傳值是跟Close一樣是一個序列，可以使用[]的語法來讀取前期值。\n資料欄位支援Tick、分鐘、日、週、月、季、半年、年、還原日、還原月、還月季等頻率，視欄位內容決定支援的頻率，在插入欄位的畫面中會列出欄位支援的商品及頻率。\n選股腳本不支援Tick、分鐘頻率，同樣也能在呼叫GetField時指定引用的資料頻率，\n當使用者選擇「外資買賣超」欄位時，頻率選項內會列出這個欄位可以被使用的頻率：日、週、月。如果使用者選擇週的話，則按插入後編輯器內會出現以下的程式碼:\nGetField("外資買賣超","W");\n注意到GetField的第二個參數傳入了 "W"，代表要抓取週線頻率。當GetField函數內傳入了指定頻率時，則不管腳本執行的頻率是什麼，系統一定會回傳這個欄位指定的頻率內容。\n以下是GetField的頻率代碼清單：\nTick: 1 Tick\n1: 1分鐘。也可使用其他數字（1、2、3、5、10、15、20、30、45、60、90、120、135、180、240），代表對應的分鐘線資料\nD: 日資料\nW: 週資料\nM: 月資料\nQ: 季資料\nH: 半年資料\nY: 年資料\nAD: 還原日資料\nAW: 還原週資料\nAM: 還原月資料\n如果在頻率選項內選擇「預設」的話，則產生的GetField程式碼內將不會傳入第二個參數。這表示當GetField執行時回傳的資料頻率會跟腳本執行的頻率是一樣的。\n如果GetField函數內傳入了頻率參數，而且這個頻率跟目前腳本執行的頻率不一樣的話，則我們稱這種情形為跨頻率。\nIf Close > Close[1] and\n2 GetField("外資買賣超","W") > GetField("外資買賣超","W") [1] then ret = 1;\n上述選股腳本內我們使用日頻率來執行，所以Close, Close[1]都是日頻率的資料，而GetField("外資買賣超","W")則是週頻率的資料。 當腳本執行時遇到要讀取不同頻率的資料時，系統會使用以下的方式來決定不同頻率的資料的日期:\n目前腳本執行的頻率為主頻率，以上例而言主頻率為日頻率，如果要讀取週頻率資料時，以日資料的計算日期來取得當下的週資料；例如，台積電(2330) 在2018/07/16~2018/07/20期間中：\n週一07/16的週線外資買賣超為-2071張、週線開盤價為224.5元、週線最高價為225元、週線最低價為223.5元、週線收盤價為223.5元、週線成交量為16107張。\n週二07/17的週線外資買賣超為-3371張、週線開盤價為224.5元、週線最高價為225元、週線最低價為221元、週線收盤價為221.5元、週線成交量為38661張。\n週三07/18的週線外資買賣超為-1733張、週線開盤價為224.5元、週線最高價為225元、週線最低價為221元、週線收盤價為223元、週線成交量為84464張。\n週四07/19的週線外資買賣超為6021張、週線開盤價為224.5元、週線最高價為227元、週線最低價為221元、週線收盤價為224.5元、週線成交量為128440張。\n週五07/20的週線外資買賣超為43423張、週線開盤價為224.5元、週線最高價為237.5元、週線最低價為221元、週線收盤價為237.5元、週線成交量為232092張。\n如果依照上述邏輯所對應出來的期別資料不存在的話，則系統會依照資料對位(DataAlign)的設定方式來決定如何處理：\n如果是絕對對位的話，則腳本執行時會發生錯誤(資料不存在)，\n如果是遞補對位的話，則系統會往前尋找有資料的期別。以上述為例，假如日期為2018/07/16日，腳本內要去讀取週資料時，依照日期對位邏輯，系統會先找尋2018/07/16日的週資料，如果資料不存在的話則會往前找尋2018/07/13日的週資料，如果還不存在的話則會往前繼續尋找，直到找到為止。\n通常在選股腳本內會使用遞補對位(預設值)來來處理財報/營收等資料期別比交易價位資料期別落後公佈的情形。\n其他與欄位相關的函數還有 GetFieldDate函數以及GetQuote函數。\n也可以利用GetSymbolField取得指定商品的欄位資料（跨商品），語法和GetField類似，只需要在第一個參數加上指定商品的SymbolID。

---

### Tangent

正切值 = Tangent(角度)

**說明:**

數學函數

---

### Tan

**說明:**

數學函數\n正切值 = Tag(角度)\n輸入角度，回傳對應的正切值。

**範例:**

```xs
Value1 = Tan(45);  // Value1 = 1.0
```

---

### SumList

**說明:**

回傳加總值 = SumList(數值1, 數值2, 數值3, ..)\n數學函數

**範例:**

```xs
Value1 = SumList(Open, High, Low, Close) / 4;
```

上述範例內使用SumList來計算平均價格 ((開盤價 + 最高價 + 最低價 + 收盤價) / 4)。
請注意: 如果要計算序列型的數值的加總值的話，則可以使用Summation函數。

---

### SquareRoot

回傳數值 = SquareRoot(數值)

**說明:**

數學函數\nValue1 = SquareRoot(100); // Value1 = 10\n請參考 Square函數。

---

### Square

回傳數值 = Square(數值)

**說明:**

數學函數\nValue1 = Square(10); // Value1 = 100\n請參考 SquareRoot函數。

---

### Sine

正弦值 = Sine(角度)

**說明:**

數學函數

---

### Sin

正弦值 = Sin(角度)

**說明:**

數學函數\n輸入角度後回傳正弦值。

**範例:**

```xs
Value1 = Sin(30);  // Value1 = 0.5
```

---

### Sign

回傳數值 = Sign(數值)

**說明:**

數學函數\n如果是正數，回傳1，如果是負數，回傳-1，如果是0，則回傳0\nValue1 = Sign(10); // Value1 = 1\nValue2 = Sign(-10); // Value2 = -1\nValue3 = Sign(0); // Value3 = 0

---

### Round

回傳數值 = Round(數值，小數位數)

**說明:**

數學函數\nValue1 = Round(10.547, 0); // Value1 = 11\nValue2 = Round(10.547, 1); // Value1 = 10.5\nValue3 = Round(10.547, 2); // Value1 = 10.55\n請參考 Ceiling函數 以及 Floor函數

---

### Random

**說明:**

隨機亂數 = Random(最大亂數的範圍)\n數學函數\nValue1 = Random(10);\nValue1的數值會是一個介於0跟10之間的隨機數字 (0 <= Value1 And Value1 < 10)，而且每次執行時Value1的數值都會不相同。\n一般而言會在計算統計相關數字時使用隨機數字來模擬可能的數值分配情境。

---

### Power

回傳數值 = Power(底數, 指數)

**說明:**

數學函數\nValue1 = Power(10, 2); // Value1 = 10的2次方 = 100

---

### Pos

回傳數值 = Pos(數值)

**說明:**

數學函數\nValue1 = Pos(-10); // Value1 = 10\nValue2 = Pos(10); // Value2 = 10

---

### Permutation

**說明:**

回傳數值 = Permutation(集合個數M, 欲取出的個數N)\n數學函數

**範例:**

```xs
Value1 = Permutation(3, 2);  // Value1 = 6
```

假設母集合有三個數字 A, B, C, 則取出任意兩個不同數字的可能排列方式 = (A,B), (A,C), (B,A), (B,C), (C,A), (C,B) 共六種。
請參考 Combination函數

---

### NthMinList

**說明:**

回傳數值 = NthMinList(排名位置, 數值1, 數值2, 數值3, ..)\n數學函數\n舉例:\nValue1 = NthMinList(1, 50, 50, 40, 30); // Value1 = 30\nValue2 = NthMinList(2, 50, 50, 40, 30); // Value2 = 40\nValue3 = NthMinList(3, 50, 50, 40, 30); // Value3 = 50\nValue4 = NthMinList(4, 50, 50, 40, 30); // Value4 = 50\n上述計算 50, 50, 40, 30 這四個數字由小到大的排名數字。請注意傳入的數值內有兩個50，分居排名3跟4。\n請參考 NthMaxList函數。

---

### NthMaxList

**說明:**

回傳數值 = NthMaxList(排名位置, 數值1, 數值2, 數值3, ..)\n數學函數\n舉例:\nValue1 = NthMaxList(1, 50, 50, 40, 30); // Value1 = 50\nValue2 = NthMaxList(2, 50, 50, 40, 30); // Value2 = 50\nValue3 = NthMaxList(3, 50, 50, 40, 30); // Value3 = 40\nValue4 = NthMaxList(4, 50, 50, 40, 30); // Value4 = 30\n上述計算 50, 50, 40, 30 這四個數字由大到小的排名數字。請注意傳入的數值內有兩個50，分居排名1跟2。

**範例:**

```xs
Value1 = NthMaxList(1, Close, Close[1], Close[2], Close[3], Close[4]);
Value2 = NthMaxList(5, Close, Close[1], Close[2], Close[3], Close[4]);
```

使用NthMaxList取得近5日的最高收盤價以及最低收盤。
當排名位置為1時，NthMaxList函數等同於MaxList函數。當排名位置為最後一名時，NthMaxList函數等同於MinList函數。

---

### Neg

回傳數值 = Neg(數值)

**說明:**

數學函數\nValue1 = Neg(5); // Value1 = -5\nValue2 = Neg(-5); // Value2 = -5\n請參考Pos函數。

---

### Mod

餘數 = Mod(被除數，除數)

**說明:**

數學函數\nValue1 = Mod(10, 2); // Value1 = 0 (可以整除)\nValue2 = Mod(10, 3); // Value2 = 1(不能整除，除完後餘1)

---

### MinList2

回傳數值 = MinList2(數值1, 數值2, 數值3, ..)

**說明:**

數學函數

**範例:**

```xs
Value1 = MinList2(1, 2, 3, 4, 5);  // Value1 = 2;
```

---

### MinList

回傳數值 = MinList(數值1, 數值2, 數值3, ..)

**說明:**

數學函數\n以下是一個腳本範例:\nValue1 = Average(Close, 5);\nValue2 = Average(Close, 10);\nValue3 = Average(Close, 20);\nIf Open < MinList(Value1, Value2, Value3) And\n5 Close > MaxList(Value1, Value2, Value3)\nThen Ret = 1;\n在這個腳本內使用MinList來算出5日/10日/20日均線的最小值。當開盤價低於均線且收盤價站上均線時觸發訊號。\n腳本內同時使用到MaxList函數，這個函數的用法類似MinList，傳入多個數值後回傳這些數值的最大值。

---

### MaxList2

回傳數值 = MaxList2(數值1, 數值2, 數值3, ..)

**說明:**

數學函數

**範例:**

```xs
Value1 = MaxList2(1, 2, 3, 4, 5);  // Value1 = 4;
```

---

### MaxList

回傳數值 = MaxList(數值1, 數值2, 數值3, ..)

**說明:**

數學函數

**範例:**

```xs
Value1 = Average(Close, 5);
Value2 = Average(Close, 10);
Value3 = Average(Close, 20);
Close > MaxList(Value1, Value2, Value3)
Then Ret = 1;
```

If Open < MinList(Value1, Value2, Value3) And
在這個腳本內使用MaxList來算出5日/10日/20日均線的最大值。當開盤價低於均線且收盤價站上均線時觸發訊號。
腳本內同時使用到MinList函數，這個函數的用法類似MaxList，傳入多個數值後回傳這些數值的最小值。

---

### Log

回傳數值 = Log(數值)

**說明:**

數學函數\nValue1 = ExpValue(1);\nValue2 = Log(Value1); // 約等於1\n請參考ExpValue函數。

---

### IntPortion

回傳數值 = IntPortion(數值)

**說明:**

數學函數\nValue1 = IntPortion(10.5); // Value1 = 10\nValue2 = FracPortion(10.5); // Value2 = 0.5\n請參考 FracPortion函數。

---

### FracPortion

回傳數值 = FracPortion(數值)

**說明:**

數學函數\nValue1 = IntPortion(10.5); // Value1 = 10\nValue2 = FracPortion(10.5); // Value2 = 0.5\n請參考 IntPortion函數。

---

### Floor

回傳數值 = Floor(數值)

**說明:**

數學函數

**範例:**

```xs
Value1 = Floor(10.5); // Value1 = 10
```

請參考 Ceiling函數 以及 Round函數

---

### Factorial

回傳數值 = Factorial(數字)

**說明:**

數學函數

**範例:**

```xs
Value1 = Factorial(3); // Value1 = 6
```

---

### ExpValue

回傳數值 = ExpValue(數值)

**說明:**

數學函數\n回傳結果為 e(自然對數, 約等於2.718281828)的N次方。\nValue1 = ExpValue(1); // Value1 = 2.718281828\n請參考Log函數。

---

### CoTangent

回傳數值 = CoTangent(角度)

**說明:**

數學函數\n輸入角度後回傳餘切值。

**範例:**

```xs
Value1 = CoTangent(45);  // Value1 = 1.0
```

---

### Cosine

數值 = Cosine(角度)

**說明:**

數學函數

---

### Cos

餘弦值 = Cos(角度)

**說明:**

數學函數\n輸入角度後回傳餘弦值。

**範例:**

```xs
Value1 = Cos(60);  // Value1 = 0.5
```

---

### Combination

**說明:**

回傳數值 = Combination(集合個數M, 欲取出的個數N)\n數學函數

**範例:**

```xs
Value1 = Combination(3, 2); // Value1 = 3
```

假設母集合有三個數字 A, B, C, 則取出任意兩個數字的可能組合數 = (A,B), (B,C), (A,C) 共三種。
請參考 Permutation函數

---

### Ceiling

回傳數值 = Ceiling(數值)

**說明:**

數學函數

**範例:**

```xs
Value1 = Ceiling(10.0);  // Value1 = 10.0
Value2 = Ceiling(10.1);  // Value2 = 11.0
```

---

### AvgList

**說明:**

回傳平均值 = AvgList(數值1, 數值2, 數值3, ..)\n數學函數\nValue1 = AvgList(Open, High, Low);\n上述範例內使用AvgList來計算Typical Price ((開盤價 + 最高價 + 最低價) / 3)。\n請注意: 如果要計算序列型的數值的平均值的話，則可以使用Average函數。

---

### ArcTangent

角度 = ArcTangent(數值)

**說明:**

數學函數\n輸入數值後，算出對應的角度。

**範例:**

```xs
Value1 = ArcTangent(1);  // Value1 = 45
```

---

### ArcSine

角度 = ArcSine(數值)

**說明:**

數學函數\n輸入數值後，算出對應的角度。

**範例:**

```xs
Value1 = ArcSine(0.5);  // Value1 = 30
```

---

### ArcCosine

角度 = ArcCosine(數值)

**說明:**

數學函數\n輸入數值後，算出對應的角度。

**範例:**

```xs
Value1 = ArcCosine(0.5);  // Value1 = 60
```

---

### AbsValue

回傳數值 = AbsValue(數值)

**說明:**

數學函數\nValue1 = Abs(3);\nValue2 = Abs(-3);\n在上面範例內, Value1跟Value2的數值都是3。\n以下使用AbsValue來計算兩條均線的差異，由於腳本只關心差異的大小，所以使用AbsValue函數來取得絕對值，不用考慮正負號。\nValue1 = Average(Close, 5);\nValue2 = Average(Close, 10);\nValue3 = AbsValue(Value1 - Value2);\nIf Value3 <= 0.01 \* Close Then Ret = 1;

---

### UpperStr

回傳字串 = UpperStr(原始字串)

**說明:**

字串函數\nVar: str1("");\n2\n3\nstr1 = UpperStr("abcdefg"); // str1 = "ABCDEFG"\n請參考LowerStr函數

---

### Text

回傳字串 = Text(參數1, 參數2, 參數3, ...)

**說明:**

字串函數\n舉例:\nVariables: str("");\n2\n3\nstr = Text("Close=", 10);\n上述範例執行之後 str變數的值會變成 "Close=10"。\n這個函數可以搭配Print函數來控制印出來的結果。

---

### StrTrim

str1 = StrTrim(字串, 選項);

**說明:**

字串函數\n- 傳入字串後，去除這個字串開頭以及結尾的空白後回傳字串。\n- 預設是刪除空白。\n- 可以傳入第二個參數選項，指定刪除的範圍。\n- 選項是一個數字，0 = 頭尾都刪除(如同預設)， 1 = 只去除開頭的空白，2 = 只去除結尾的空白。

**範例:**

```xs
str1 = StrTrim("  hello world ");
str1 = StrTrim("  hello world ", 0);
str1 = StrTrim("  hello world ", 1);
str1 = StrTrim("  hello world ", 2);
```

2//回傳的字串會是"hello world"。
3
4
6//回傳的字串會是 "hello world"。
7
8
10//回傳的字會是 "hello world "。
11
12
14//回傳的字串會是" hello world"。

---

### StrToNum

回傳數值 = StrToNum(字串)

**說明:**

字串函數\nValue1 = StrToNum("123.45"); // Value1 = 123.45\n請參考NumToStr函數。

---

### StrStartWith

condition1 = StrStartWith(字串1, 字串2, 比對方式);

**說明:**

字串函數\n- 傳入兩個字串, 判斷第一個字串的開頭是否與第二個字串的完整內容相同。\n- 回傳布林值。\n- 預設的比對方式是不分大小寫，可以傳入第三個參數指定比對的方式，True表示不區分大小寫。\n預設的比對方是不區分字母大小寫，但可以透過傳入第三個參數來改變。

**範例:**

```xs
condition1 = StrStartWith(“ABCDEFG”, “ABC”);
condition1 = StrStartWith(“ABCDEFG”, “DEF”);
condition1 = StrStartWith(“ABCDEFG”, “abc”);
condition1 = StrStartWith(“ABCDEFG”, “abc”, false);
```

2//回傳 True。
3
4
6//回傳 False。
7
8
10//回傳 True。(預設是不區分大小寫)
11
12
14//回傳 False。

---

### StrSplit

**說明:**

字串函數\n- 把一個字串依照指定的分隔字串切割成多個子字串。\n- 需傳入三個參數，第一個參數是要切割的字串，第二個參數是分隔字串，第三個參數是一個一維的字串陣列。\n- 切割後的子字串會依序放入輸出陣列內，如果陣列的大小已經固定，則至多只會放入這麼多個子字串，如果陣列是動態陣列，則當陣列空間不夠時，系統會自動調整陣列的大小，以便放入所以切割出來的子字串。\n- 回傳值為切割得到的子字串的個數。

**範例:**

```xs
Array: tokens[](""), tokens2[3]("");
value1 = StrSplit("A,B,C,D,E", ",", tokens);
value2 = StrSplit("A,B,C;D,E", ",", tokens2);
tokens2[1] = "A", tokens2[2] = "B", tokens2[3] = "C;D"。
```

2
3
value1 會是5。
tokens因為是動態陣列，所以會被自動調整成5個元素的大小。
tokens[1] = "A", tokens[2] = "B", tokens[3]="C", tokens[4]="D", tokens[5]="E"。
因為tokens2的大小已經固定，所以value2會是3。

---

### StrLen

字串長度 = StrLen(字串)

**說明:**

字串函數\nValue1 = StrLen("abcdefg"); // Value1 = 7

---

### StrEndWith

condition1 = StrEndWith(字串1, 字串2, 比對方式);

**說明:**

字串函數\n- 傳入兩個字串，判斷第一個字串的結尾是否與第二個字串的完整內容相同。\n- 回傳布林值。\n- 預設的比對方式是不分大小寫，可以傳入第三個參數指定比對的方式，True表示不區分大小寫。\n預設的比對方是不區分字母大小寫，但可以透過傳入第三個參數來改變。

**範例:**

```xs
condition1 = StrEndWith(“ABCDEFG”, “DEFG”);
condition1 = StrEndWith(“ABCDEFG”, “ABC”);
condition1 = StrEndWith(“ABCDEFG”, “defg”)
condition1 = StrEndWith(“ABCDEFG”, “defg”, false);
```

2//回傳 True。
3
4
6//回傳 False。
7
8
10//回傳 True。(預設是不區分大小寫)
11
12
14//回傳 False。

---

### StrCompare

數值 = StrCompare(字串1, 字串2)

**說明:**

字串函數\n數值 = StrCompare(字串1, 字串2, 不區分大小寫)\n傳入二個以上參數:\n- 第一個參數是字串1。\n- 第二個參數是字串2。\n- 第三個參數是選用參數，True表示不區分大小寫，False代表區分大小寫，預設為不區分大小寫。\n當回傳值為 0 時，表示字串1和字串2一樣。\n當回傳值為 1 時，表示字串1順序大於字串2。\n當回傳值為 -1 時，表示字串1順序小於字串2。\n//預設為不區分大小寫，所以下列二種得到的結果是一樣的\nif StrCompare(symbol,"2330.tw") = 0 then plot1(1) else plot1(0);\nif StrCompare(symbol,"2330.TW") = 0 then plot2(1) else plot2(0);\n4//假設主商品是台積電，當區分為大小寫時，plot3會是0、plot4會是1\nif StrCompare(symbol,"2330.tw",false) = 0 then plot3(1) else plot3(0);\nif StrCompare(symbol,"2330.TW",false) = 0 then plot4(1) else plot4(0);

---

### RightStr

**說明:**

子字串 = RightStr(原始字串，字元長度)\n字串函數\n第一個參數是原始字串\n第二個參數是欲取出的字元個數\n回傳值是從原始字串右邊開始長度為第二個參數的子字串。\nVar: str1("");\n2\n3\nstr1 = RightStr("abcdefg", 3); // str1 = "efg"\n在上面範例內，str1是"abcdefg"從右邊算起長度為3的子字串，"efg"。\n請參考 LeftStr函數 以及 MidStr函數。

---

### NumToStr

回傳字串 = NumToStr(數值，小數位數)

**說明:**

字串函數\nVar: Str1(""), Str2(""), Str3("");\n2\n3\nValue1 = 144.5;\n5\n6\nStr1 = NumToStr(Value1, 0); // Str1 = "145"\nStr2 = NumToStr(Value1, 1); // Str2 = "144.5"\nStr3 = NumToStr(Value2, 2); // Str3 = "144.50"\n在上例內，Str1的字串值是144.5四捨五入後換算的結果 "145"，而Str3的字串值則在小數位數1之後補0，以確保有兩位小數 "144.50"。\n請參考StrToNum函數。

---

### MidStr

**說明:**

子字串 = MidStr(原始字串，指定位置，子字串長度)\n字串函數\n第一個參數是原始字串\n第二個參數是欲取出的子字串的起始位置\n第三個參數是欲取出的子字串的字元長度

**範例:**

```xs
Var: str1(""), str2("");
str1 = MidStr("abcdefg", 1, 3);  // str1 = "abc"
str2 = MidStr("abcdefg", 2, 3);  // str1 = "bcd"
```

2
3
在上面範例內，str1是"abcdefg"這個字串第一個位置開始長度為3的子字串, "abc"，而str2則是"abcdefg"這個字串第二個位置開始長度為3的子字串, "bcd"。
請參考 LeftStr函數 以及 RightStr函數。

---

### LowerStr

回傳字串 = LowerStr(原始字串)

**說明:**

字串函數\nVar: str1("");\n2\n3\nstr1 = LowerStr("ABCDEFG"); // str1 = "abcdefg"\n請參考UpperStr函數

---

### LeftStr

**說明:**

子字串 = LeftStr(原始字串，字元長度)\n字串函數\n第一個參數是原始字串\n第二個參數是欲取出的字元個數\n回傳值是從原始字串左邊開始長度為第二個參數的子字串。\nVar: str1("");\n2\n3\nstr1 = LeftStr("abcdefg", 3); // str1 = "abc"\n在上面範例內，str1是"abcdefg"從左邊算起長度為3的子字串，"abc"。\n請參考 RightStr函數 以及 MidStr函數。

---

### InStr

**說明:**

比對位置 = InStr(原始字串, 比對字串);\n字串函數\n比對位置 = InStr(字串1, 字串2, 比對開始位置);\n- 回傳比對字串位於原始字串的位置，如果不存在的話則回0。\n- 第三個參數可以指定比對的開始位置，預設是從第一個位置開始找起。\n第一個參數是原始字串。\n第二個參數是欲比對的字串。\n第三個參數可以指定比對開始的位置。\n如果欲比對的字串是原始字串的一部份的話，則回傳這個字串位於原始字串的位置。反之則回傳0。\nValue1 = InStr("abcdefg", "bc"); // Value1 = 2\nValue2 = InStr("abcdefg", "xyz"); // Value2 = 0\nValue3 = InStr("Hello Hello", "Hello", 6); //Value3 = 7\n在上述範例內，"bc"是"abcdefg"的一部份，所以Value1的值會是"bc"位於"abcdefg"內的位置，第2個字元。而"xzy"並不是"abcdefg"的一部份，所以Value2 = 0。\nValue3 則是因為指定要從第6個位置開始找起，所以會找到第二個Hello，故回7。

---

### Year

年度 = Year(日期)

**說明:**

日期函數\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳的數值則是這個日期的所在年度。\n舉例：\nValue1 = Year(20150601);　　// Value1 = 2015\n日期相關的函數請參考Year函數，Month函數，DayOfMonth函數，DayOfWeek函數，WeekOfMonth函數，以及WeekOfYear函數。

---

### WeekOfYear

第幾個星期 = WeekOfYear(日期)

**說明:**

日期函數\n回傳數值的範圍從1到53\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳的數值則是這一年第幾個星期，可能的數值從1到53。\nValue1 = WeekOfYear(20150101); // Value1 = 1 (第一週)\n日期相關的函數請參考Year函數，Month函數，DayOfMonth函數，DayOfWeek函數，WeekOfMonth函數，以及WeekOfYear函數。

---

### WeekOfMonth

第幾個星期 = WeekOfMonth(日期)

**說明:**

日期函數\n回傳數值的範圍從1到6\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳的數值則是這個日期是這個月的第幾個星期，可能的數值從1到6。\nValue1 = WeekOfMonth(20150601); // Value1 = 1 (第一週)\n日期相關的函數請參考Year函數，Month函數，DayOfMonth函數，DayOfWeek函數，WeekOfMonth函數，以及WeekOfYear函數。

---

### StringToDate

日期數值 = StringToDate( 日期字串)

**說明:**

日期函數\n日期字串的格式為"YYYY/MM/DD"，而回傳的日期格式為YYYYMMDD的8碼數字\nValue1 = StringToDate("2015/06/01"); // Value1 = 20150601\n請參考DateToString函數。

---

### Month

月份 = Month(日期)

**說明:**

日期函數\n回傳月份的範圍從1到12\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳的數值則是這個日期的月份，可能的數值從1到12。\n舉例：\nValue1 = Month(20150601);　　// Value1 = 6\n日期相關的函數請參考Year函數，Month函數，DayOfMonth函數，DayOfWeek函數，WeekOfMonth函數，以及WeekOfYear函數。

---

### JulianToDate

日期 = JulianToDate(儒略日數值)

**說明:**

日期函數\n請參考DateToJulian函數的說明。

---

### FormatDate

**說明:**

字串 = FormatDate(格式字串組合, 日期數值)\n日期函數\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n格式字串可以是以下字串的組合:\nd: 回傳這個日期是這個月的第幾天，如果不到兩位數，前面不補零，例如5號的話回傳 "5"，15號的話回傳 "15"，\ndd: 回傳這個日期是這個月的第幾天，如果不到兩位數，前面補零，例如5號的話回傳 "05"，15號的話回傳 "15"，\nddd: 回傳這個日期是星期幾的英文縮寫，分別是"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"\ndddd: 回傳這個日期是星期幾的英文全名，分別是"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"\nM: 回傳這個日期的月份，如果不到兩位數，前面不補零，例如1月回傳 "1"，12月回傳 "12"，\nMM: 回傳這個日期的月份，如果不到兩位數，前面補零，例如1月回傳 "01"，12月回傳 "12"，\nMMM: 回傳這個日期的月份英文簡稱，分別是 "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"，\nMMMM: 回傳這個日期的月份英文全名，分別是 "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"\ny: 回傳這個日期的年份後兩碼，如果不到兩位數前面不補零，例如2005年的話則回傳"5", 2015年的話則回傳"15"，\nyy: 回傳這個日期的年份後兩碼，如果不到兩位數前面補零，例如2005年的話則回傳"05", 2015年的話則回傳"15"，\nyyy: 回傳這個日期的年份後兩碼，如果不到兩位數前面補零，例如2005年的話則回傳"05", 2015年的話則回傳"15"，\nyyyy: 回傳這個日期的4碼年份，例如2005年的話則回傳 "2005"，\n格式字串內除了可以使用上面字串的組合之外，也可以搭配其他的字元。

**範例:**

```xs
Value1 = FormatDate("yyyy/MM/dd", 20150601);  // Value1 = "2015/06/01"
```

注意到格式字串內有使用"/"字串，這些額外的字串也會出現在回傳字串內。

---

### EncodeDate

日期數值 = EncodeDate(年份, 月份, 日期)

**說明:**

日期函數\n第一個參數是年份(YYYY)，4碼數字，例如 2015，\n第二個參數是月份(MM)，數值範圍為1到12，\n第三個參數是日期(DD)，數值範圍為1到31\n函數回傳值的格式為8碼的日期數字。

**範例:**

```xs
Value1 = EncodeDate(2015,1,1);   // Value1 = 20150101
Value2 = EncodeDate(2015,12,31); // Value2 = 20151231
```

---

### DayOfWeek

第幾天 = DayOfWeek(日期)

**說明:**

日期函數\n如果是星期日的話則回傳0, 星期一的話則回傳1, 由此類推\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳的數值則是這個日期是這個星期的第幾天，可能的數值從0(星期日)到6(星期六)。

**範例:**

```xs
If DayOfWeek(Date) = 1 Then
```

Begin
3 // 目前K棒資料日期是星期一
End;
日期相關的函數請參考Year函數，Month函數，DayOfMonth函數，DayOfWeek函數，WeekOfMonth函數，以及WeekOfYear函數。

---

### DayOfMonth

天數 = DayOfMonth(日期)

**說明:**

日期函數\n回傳數值的範圍從1到31\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳的數值則是這個日期是這個月的第幾天，可能的數值從1到31。\n舉例：\nValue1 = DayOfMonth(20150601); // Value1 = 1\nValue2 = DayOfMonth(20150630); // Value2 = 30\n日期相關的函數請參考Year函數，Month函數，DayOfMonth函數，DayOfWeek函數，WeekOfMonth函數，以及WeekOfYear函數。

---

### DateValue

**說明:**

欄位數值 = DateValue(日期數值，指定欄位)\n日期函數\n指定欄位有 Y(回傳年度), M(回傳月份), D(回傳月份的第幾天), DW(回傳星期幾), WM(回傳月份的第幾週), WY(回傳當年的第幾週)\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳數值依照指定欄位而有不同:\n如果是Y，則回傳日期的西元年度\n如果是M，則回傳日期的月份，範圍從1到12\n如果是D，則回傳這個月的第幾天，範圍從1到31\n如果是DW，則回傳星期幾，星期天為0, 星期一為1, 星期二為2, 由此類推\n如果是WM，則回傳這個月份的第幾週，範圍從1到6\n如果是WY，則回傳當年的第幾週，範圍從1到53

**範例:**

```xs
Value1 = DateValue(20150601, "Y");  // Value1 = 2015
Value2 = DateValue(20150601, "M");  // Value2 = 6
Value3 = DateValue(20150601, "D");  // Value3 = 1
Value4 = DateValue(20150601, "DW"); // Value4 = 1 (星期一)
Value5 = DateValue(20150601, "WM"); // Value5 = 1 (6月第一週)
Value6 = DateValue(20150601, "WY"); // Value6 = 23 (2015年第23週)
```

這個函數可以看成是Year函數，Month函數，DayOfMonth函數，DayOfWeek函數，WeekOfMonth函數，以及WeekOfYear函數等函數的綜合體。

---

### DateToString

日期字串 = DateToString(日期數值)

**說明:**

日期函數\n回傳的日期字串格式為YYYY/MM/DD\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n日期數值通常是透過CurrentDate，或是Date(資料的日期欄位)，或是其他日期相關函數所產生的日期數值。\n回傳字串的格式是"YYYY/MM/DD"，其中YYYY為４位年份，MM為月份，從01到12，DD則是日期，從01到31。\n舉例而言，如果目前日期是20150601的話，以下的程式碼\nPrint(DateToString(CurrentDate));\n將會印出 "2015/06/01"的字串。\n請參考StringToDate函數。

---

### DateToJulian

儒略日 = DateToJulian(日期數值)

**說明:**

日期函數\n另外一種計算方式，則是把日期轉換成儒略日格式後再來計算。因為儒略日格式採用絕對天數的方式來紀錄日期數值，所以可以直接做數值運算，然後再使用JulianToDate函數轉成YYYYMMDD的8碼日期格式。\nValue1 = DateToJulian(20150601); // 把20150601轉成Julian格式\nValue1 = Value1 + 1; // 直接加1天\nValue2 = JulianToDate(Value1); // Value2 = 20150602

---

### DateDiff

**說明:**

差異天數 = DateDiff(第一個日期數值，第二個日期數值)\n日期函數\n請傳入日期格式YYYYMMDD\nDateDiff回傳的數值是第一個日期減第二個日期的差異天數，如果第一個日期小於第二個日期的話，則回傳的數值是負數。\nValue1 = DateDiff(20160601, 20160501); // Value1 = 31(日)\nValue2 = DateDiff(20160601, 20160602); // Value2 = -1(日)\n一般可以利用這個函數來判斷價位日期之間的關係\nif High > Highest(Close[1],60) and DateDiff(CurrentDate, Date) < 5 then ret=1;\n以上的警示範例(使用日資料執行)會在近5日內創60日新高時觸發。注意到腳本內使用DateDiff來判斷創新高的日期(Date)是否與目前電腦日期(也就是執行當日)的差異是在5日之內。

---

### DateAdd

**說明:**

回傳日期 = DateAdd(日期數值，要運算的日期欄位單位，要增加的數值)\n日期函數\n第一個參數是開始計算的日期，格式為YYYYMMDD的8碼數字\n第二個參數是要運算的日期欄位，如果是年則傳"Y"，如果是月則傳"M"，如果是日則傳"D"\n第三個參數是要增加的數值，可以是正數或是負數\n回傳計算後的日期，格式也是YYYYMMDD的8碼數字\nYYYY是西元年份，例如2015，\nMM是月份，兩位數字，範圍從01到12，\nDD是日期，兩位數字，範圍從01到31，\n第二個參數是要執行運算的日期欄位單位，如果我們要計算第一個日期的後幾年的是哪一天的話，則傳入"Y"，如果我們要計算第一個日期的後幾月是哪一天的話，則傳入"M"，如果我們要計算第一個日期的後幾日的是哪一天的話，則傳入"D"。\n第三個參數則是要增加的數值，可以是正數(表示往後加), 也可以是負數(表示往前減)。\nDateAdd函數回傳的數值也是YYYYMMDD的日期格式。

**範例:**

```xs
Value1 = DateAdd(20150601, "Y", 1);  // Value1 = 20160601, 加1年
Value2 = DateAdd(20150601, "M", 1);  // Value2 = 20150701, 加1個月
Value3 = DateAdd(20150601, "D", 1);  // Value3 = 20150602, 加1天
Value4 = DateAdd(20150601, "D", -1); // Value4 = 20150531, 減1天
```

---

### CurrentDate

```xs
Print("CurrentDate=", CurrentDate);
```

**說明:**

日期函數\n回傳日期 = CurrentDate\n日期格式是一個8碼的數字, 例如如果是2015年6月1日, 則回傳20150601\n即時區間為當日的意思是，腳本執行在當下，因此CurrentDate就會是今天。\n回傳的日期格式是一個8碼的數字 YYYYMMDD:\nYYYY: 執行的年度，例如2015，4碼，\nMM: 執行的月份，數值範圍從01到12，2碼，\nDD: 執行的日期，數值範圍從01到31，2碼\n舉例而言，如果執行日期是2015年6月1日，則CurrentDate回傳 20150601。

---

### TimeValue

**說明:**

欄位數值 = TimeValue(時間數值，指定欄位)\n時間函數\n指定欄位有 H(回傳小時), M(回傳分鐘), S(回傳秒數), MS(回傳毫秒)\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\n時間數值通常是透過CurrentTime，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\n回傳數值依照指定欄位分別定義:\n如果是 H 的話，則回傳時間的小時數，範圍從0到23(24小時制)\n如果是 M 的話，則回傳時間的分鐘數，範圍從0到59\n如果是 S 的話，則回傳時間的秒數，範圍從0到59\n時間數值也可以是一個含有毫秒的 8~9碼 的數字，格式為HHMMSS.fff：\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\n含有毫秒的時間數值通常是透過CurrentTimeMS，FilledRecordTimeMS，或是其他時間相關函數所產生的時間數值。\n回傳數值依照指定欄位分別定義:\n如果是 H 的話，則回傳時間的小時數，範圍從0到23(24小時制)\n如果是 M 的話，則回傳時間的分鐘數，範圍從0到59\n如果是 S 的話，則回傳時間的秒數，範圍從0到59\n如果是 MS 的話，則回傳時間的毫秒，範圍從0到999

**範例:**

```xs
Value1 = TimeValue(CurrentTime, "H");
Value2 = TimeValue(CurrentTimeMS, "MS");
If Value1 >= 12 Then Begin
```

3
4
6 // 目前時間是中午12點過後
End;
8
9
if Value2 >= 500 Then Begin
11 // 目前時間是 500 毫秒過後
End;
這個函數可以看成是 Hour, Minute, Second, 以及 MilliSecond 還有的綜合體。

---

### TimeToString

時間字串 = TimeToString(時間數值)

**說明:**

時間函數\n回傳的時間字串格式為HH:MM:SS\n回傳的時間字串格式也可以為HH:MM:SS.fff\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\n時間數值通常是透過CurrentTime，CurrentTimeMS，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\n回傳字串的格式是"HH:MM:SS"，其中HH(小時)的範圍從00到23 (24小時制，兩碼)，MM(分鐘)的範圍從00到59，SS(秒數)的範圍從00到59。\n舉例而言，如果目前時間是9點30分00秒，以下的程式碼\nPrint(TimeToString(CurrentTime));\n將會印出 "09:30:00"的字串。\n如果回傳字串的格式是"HH:MM:SS.fff"，其中HH(小時)的範圍從00到23 (24小時制，兩碼)，MM(分鐘)的範圍從00到59，SS(秒數)的範圍從00到59，fff(毫秒)的範圍從000到999。\n例如目前時間是9點30分00秒500毫秒，以下的程式碼\nPrint(TimeToString(CurrentTimeMS));\n將會印出 "09:30:00.500"的字串。\n請參考StringToTime函數。

---

### TimeDiff

**說明:**

差異 = TimeDiff(第一個時間數值，第二個時間數值, 要計算差異的單位)\n時間函數\n計算的單位可以是"H"(小時), "M"(分鐘), "S"(秒數), 或是"MS"(毫秒)\n回傳數值是第一個時間減第二個時間差幾個小時，幾分鐘，幾秒鐘，或是幾毫秒\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\n時間數值通常是透過CurrentTime，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\n時間數值也可以是一個含有毫秒的 8~9 碼的數字，格式是HHMMSS.fff：\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\n通常是透過CurrentTimeMS，FilledRecordTimeMS，或是其他含有毫秒的時間相關函數所產生的時間數值。\nTimeDiff回傳的數值是第一個時間減第二個時間的差異:\n如果第三個參數是"H"，則回傳兩個時間差換算成小時數，\n如果第三個參數是"M"，則回傳兩個時間換算成分鐘數，\n如果第三個參數是"S"，則回傳兩個時間換算成秒數。\n如果第三個參數是"MS"，則回傳兩個時間換算成毫秒。\n如果第一個時間小於第二個時間的話，則回傳的數值是負數。\nValue1 = TimeDiff(130000, 120000, "H"); // Value1 = 1(小時)\nValue2 = TimeDiff(133000, 123000, "M"); // Value2 = 60(分鐘)\nValue3 = TimeDiff(133000, 090000, "M"); // Value3 = 270(分鐘)\nValue4 = TimeDiff(123000, 130000, "H"); // Value4 = -0.5(小時)\nValue5 = TimeDiff(120000.123, 120000, "MS"); // Value5 = 123(毫秒)\n底下是一個應用範例，使用１分鐘資料。利用TimeDiff來計算大單成交的時間間隔，如果發生的很密集的話則觸發。\nVar: vTime(0);\nif getfielddate("Date") <> getfielddate("Date")[1] then vTime = 0;\nIf Volume\*Close > 10000 then vTime =Time; // 紀錄交易金額大於1000萬的K棒時間\nIf vTime <> vTime[1] and absValue(TimeDiff(vTime, vTime[1], "M")) < 5 Then begin\n5 ret = 1;\n6 print(vTime, vTime[1], absvalue(TimeDiff(vTime, vTime[1], "M")));\nend;

---

### TimeAdd

**說明:**

回傳時間 = TimeAdd(時間數值，要運算的時間欄位單位，要增加的數值)\n時間函數\n第一個參數是開始計算的時間，格式為HHMMSS，或者HHMMSS.fff的時間數字\n第二個參數是要運算的時間欄位，如果是小時則傳"H"，如果是分鐘則傳"M"，如果是秒的話則傳"S"，如果是毫秒的話則傳"MS"\n第三個參數是要增加的數值，可以是正數或是負數\n回傳計算後的時間，格式也是 HHMMSS 或 HHMMSS.fff 的時間數字\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\n通常是透過CurrentTime，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\n時間數值也可以是一個含有毫秒的 8~9 碼的數字，格式是HHMMSS.fff：\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\n通常是透過CurrentTimeMS，FilledRecordTimeMS，或是其他含有毫秒的時間相關函數所產生的時間數值。\n第二個參數是要執行運算的時間欄位單位，如果我們要計算第一個時間的後幾小時的話，則傳入"H"，如果我們要計算第一個時間的後幾分的話，則傳入"M"，如果我們要計算第一個時間的後幾秒的話，則傳入"S"，如果我們要計算第一個時間的後幾毫秒的話，則傳入"MS"。\n第三個參數則是要增加的數值，可以是正數(表示往後加), 也可以是負數(表示往前減)。\nTimeAdd回傳的數值也是HHMMSS或者HHMMSS.fff的時間格式。

**範例:**

```xs
Value1 = TimeAdd(120000, "H", 1);	// Value1 = 130000
Value2 = TimeAdd(123000, "M", -30); // Value2 = 120000
Value3 = TimeAdd(120000, "MS", 1); // Value3 = 120000.001
Var: HighTime(0);
if Date <> Date[1] then HighTime = 0;
if H > Highest(H[1],60) then HighTime = Time;
if HighTime > 0 And Time > HighTime And Time < TimeAdd(HighTime,"H",1) Then
```

以下是一個應用範例，使用１分鐘頻率執行，利用TimeAdd來判斷目前資料是否是位於創新高後的１小時內:
4
5
Begin
8 // 創新高後的1小時內
End;
請注意上述範例內當Date不等於Date[1]時(分鐘線資料換日)必須把HighTime清掉，以確保HighTime是當日創新高的時間點。

---

### StringToTime

時間數值 = StringToTime( 時間字串)

**說明:**

時間函數\n時間字串的格式為"HH:MM:SS"，而回傳的時間格式為HHMMSS的6碼數字\n時間字串的格式也可以是"HH:MM:SS.fff"，回傳的時間格式則為HHMMSS.fff的9碼數字\nif CurrentTime > StringToTime("13:00:00") Then Begin\n2 // 目前時間大於中午13:00:00\nEnd;\n4\n5\nif CurrentTimeMS > StringToTime("13:00:00.500") Then Begin\n7 // 目前時間大於中午13:00:00.500\nEnd;\n請參考TimeToString函數。

---

### Second

秒數 = Second(時間數值)

**說明:**

時間函數\n回傳秒數的數值範圍從0到59\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\n時間數值通常是透過CurrentTime，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\nValue1 = CurrentTime;\nIf Hour(Value1) = 13 And Minute(Value1) = 05 And Second(Value1) >= 30 Then\nBegin\n4 // 目前時間 >= 13:05:30\nEnd;\n時間數值也可以是一個含有毫秒的 8~9 碼的數字，格式是HHMMSS.fff：\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\n含有毫秒的時間數值，通常是透過CurrentTimeMS，FilledRecordTimeMS，或是其他時間相關函數所產生的時間數值。\n以下的範例是用 CurrentTimeMS 傳入的時間數值\nValue2 = CurrentTimeMS;\nIf Hour(Value2) = 13 And Minute(Value2) = 05 And Second(Value2) >= 30 Then\nBegin\n4 // 目前時間 >= 13:05:30\nEnd;\n時間相關的的函數請參考Hour函數，Minute函數，Second函數，以及MilliSecond

---

### Minute

分鐘數 = Minute(時間數值)

**說明:**

時間函數\n回傳分鐘數的數值範圍從0到59\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\n時間數值通常是透過CurrentTime，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\nValue1 = Minute(Time);\nIf Value1 = 0 Then\nBegin\n4 // 目前分鐘K棒資料時間是0分\nEnd;\n上述範例取得目前分鐘K棒資料時間的分鐘數值。\n時間數值也可以是一個8~9碼，含有毫秒的數字，格式是HHMMSS.fff：\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\n含有毫秒的時間數值，通常是透過CurrentTimeMS，FilledRecordTimeMS，或是其他時間相關函數所產生的時間數值。\nValue1 = Minute(CurrentTimeMS);\nIf Value1 = 0 Then\nBegin\n4 // 目前分鐘K棒資料時間是0分\nEnd;\n上述範例，也是取得目前分鐘K棒資料時間的分鐘數值，不過是傳入含有毫秒的目前電腦時間。\n時間相關的的函數請參考Hour函數，Minute函數，以及Second函數。

---

### MilliSecond

毫秒數 = MilliSecond(時間數值)

**說明:**

時間函數\n回傳秒數的數值範圍從0到999\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從0到999，必須是3位數字\n時間數值通常是透過CurrentTime，CurrentTimeMS，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\nValue1 = CurrentTimeMS;\nIf Hour(Value1) = 13 And Minute(Value1) = 05 And Second(Value1) >= 30 And MilliSecond(Value1) >= 500 Then\nBegin\n4 // 目前時間 >= 13:05:30.500\nEnd;\n時間相關的的函數請參考Hour函數，Minute函數，Second函數，以及MilliSecond

---

### Hour

小時 = Hour(時間數值)

**說明:**

時間函數\n回傳小時的數值範圍從0到23 (24小時制)\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\n時間數值通常是透過CurrentTime，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\nValue1 = Hour(Time);\n2\n3\nIf Value1 = 12 Then\nBegin\n6 // 目前分鐘K棒的資料時間是12點\nEnd;\n上述範例利用Hour取得目前分鐘K棒資料時間的小時數值。\nValue2 = Hour(CurrentTime);\nIf Value2 >= 12 Then\nBegin\n4 // 目前時間是中午12點過後\nEnd;\n上述範例則是傳入CurrentTime，也就是目前電腦的時間，格視為 HHMMSS。\n也可以傳入含有毫秒的時間數值 CurrentTimeMS 回傳格式為 HHMMSS.fff\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\nValue3 = Hour(CurrentTimeMS);\nIf Value3 >= 12 Then\nBegin\n4 // 目前時間是中午12點過後\nEnd;\n上述範例是傳入CurrentTimeMS，也是目前電腦的時間，不過是含有毫秒的電腦的時間，格式為 HHMMSS.fff。\n時間相關的的函數請參考Hour函數，Minute函數，以及Second函數。

---

### FormatTime

**說明:**

字串 = FormatTime(格式字串組合, 時間數值)\n時間函數\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\n時間數值通常是透過CurrentTime，Time(資料的時間欄位)，或是其他時間相關函數所產生的時間數值。\nCurrentTimeMS，則是含有毫秒的時間數值，是一個 8~9 碼的數字，格式是HHMMSS.fff:\nHH是小時，數值範圍從0到23，可以是1位數字或是2位數字\nMM是分鐘，數值範圍從00到59，必須是2位數字\nSS是秒數，數值範圍從00到59，必須是2位數字\nfff是毫秒，數值範圍從000到999，必須是3位數字\n格式字串可以是以下字串的組合:\nh: 回傳12小時制的小時，如果不到兩位數，前面不補零，例如上午8點的話回傳 "8"，上午11點回傳 "11", 下午4點回傳 "4"，\nhh: 回傳12小時制的小時，如果不到兩位數，前面補零，例如上午8點的話回傳 "08"，上午11點回傳 "11", 下午4點回傳 "04"，\nH: 回傳24小時制的小時，如果不到兩位數，前面不補零，例如上午8點的話回傳 "8"，上午11點回傳 "11", 下午4點回傳 "16"，\nHH: 回傳24小時制的小時，如果不到兩位數，前面補零，例如上午8點的話回傳 "08"，上午11點回傳 "11", 下午4點回傳 "16"，\nm: 回傳分鐘，如果不到兩位數，前面不補零，例如上午8點5的話回傳 "5"，上午8點15分的話則回傳 "15"，\nmm: 回傳分鐘，如果不到兩位數，前面補零，例如上午8點5的話回傳 "05"，上午8點15分的話則回傳 "15"，\ns: 回傳秒數，如果不到兩位數，前面不補零，例如上午8點5分5秒的話回傳 "5"，上午8點5分15秒的話則回傳 "15"，\nss: 回傳秒數，如果不到兩位數，前面補零，例如上午8點5分5秒的話回傳 "05"，上午8點5分15秒的話則回傳 "15"，\nt: 回傳上午或是下午的代碼，例如時間是上午的話則回傳"A", 如果時間是下午的話則回傳"P"，\ntt: 回傳上午或是下午的完整代碼，例如時間是上午的話則回傳"AM", 如果時間是下午的話則回傳"PM"，\nfff: 回傳毫秒完整代碼，如果不到三位數，前面補零，例如上午8點5分5秒5毫秒的話回傳 "005"，上午8點5分15秒555毫秒的話則回傳 "555"，\n格式字串內除了可以使用上面字串的組合之外，也可以搭配其他的字元。

**範例:**

```xs
var:_Str1(""),_Str2("");
_Str1 = FormatTime("HH:mm:ss", 132530.255);  // _Str1 = "13:25:30"
_Str2 = FormatTime("HH:mm:ss:fff", 132530.255);  // _Str2 = "13:25:30"
```

2
3
注意到格式字串內有使用":"字串，這些額外的字串也會出現在回傳字串內。

---

### EncodeTime

**說明:**

時間數值 = EncodeTime(小時數值, 分鐘數值, 秒數數值)\n時間函數\n時間數值 = EncodeTime(小時數值, 分鐘數值, 秒數數值 ,毫秒數值)\n第一個參數是小時(HH)，數值範圍為0到23 (24小時制)\n第二個參數是分鐘(MM)，數值範圍為0到59，\n第三個參數是秒數(SS)，數值範圍為0到59\n第四個參數是毫秒(MS)，數值範圍為0到999，如果省略這個參數的話，則回傳HHMMSS。\n函數回傳值的格式為5至9碼的時間數字。\n例如傳入HH=9, MM=30, SS=0的話，則回傳93000。如果傳入HH=12, MM=30, SS=0的話，則回傳123000。如果傳入HH=13, MM= 15, SS=0, MS=255 的話，則回傳 131500.255。

**範例:**

```xs
Value1 = EncodeTime(12, 30, 0);
Value2 = EncodeTime(13, 15, 0, 255);
If CurrentTime >= Value1 Then Begin
```

3
4
6 // 目前時間是中午12點30分以後
End;
8
9
if CurrentTimeMS >= Value2 Then Begin
11 // 目前時間是中午13點15分00秒255毫秒 以後
End;

---

### CurrentTimeMS

```xs
If CurrentTimeMS >= 123000.500 Then
```

**說明:**

時間函數\n回傳時間 = CurrentTimeMS\n時間格式是一個9碼的數字, 例如如果是上午的11點30分00秒500毫秒, 則回傳113000.500\n注意：不支援選股（執行選股時，數值為0）\n即時區間為當下的意思是，腳本執行在當下，因此CurrentTimeMS就會是此時此刻的時間。\n時間的格式為8碼或9碼的數字 HHMMSS.FFF:\nHH: 執行的小時，數值範圍從0到23 (24小時制), 可能是1碼或2碼，\nMM: 執行的分鐘，數值範圍從00到59，兩碼，\nSS: 執行的秒數，數值範圍從00到59，兩碼，\nFFF：執行的毫秒，數值範圍從000到999，三碼。\n舉例而言，如果執行時間是上午的9點30分00秒500毫秒，則CurrentTimeMS回傳 93000.500，如果執行時間為下午1點10分00秒500毫秒，則CurrentTimeMS回傳131000.500。\n我們可以使用這個函數來判斷腳本的執行時間，例如在以下範例內使用CurrentTimeMS來判斷腳本執行時是否已經是中午12點30分00秒500毫秒之後。\nBegin\n3 // 執行時間是中午12點30分00秒500毫秒以後\nEnd;

---

### CurrentTime

```xs
If CurrentTime >= 123000 Then
```

**說明:**

時間函數\n回傳時間 = CurrentTime\n時間格式是一個6碼的數字, 例如如果是上午的11點30分00秒, 則回傳113000\n注意：不支援選股（執行選股時，數值為0）\n即時區間為當下的意思是，腳本執行在當下，因此CurrentTime就會是此時此刻的時間。\n時間的格式為5碼或6碼的數字 HHMMSS:\nHH: 執行的小時，數值範圍從0到23 (24小時制), 可能是1碼或2碼，\nMM: 執行的分鐘，數值範圍從00到59，兩碼，\nSS: 執行的秒數，數值範圍從00到59，兩碼\n舉例而言，如果執行時間是上午的9點30分00秒，則CurrentTime回傳 93000，如果執行時間為下午1點30分00秒，則CurrentTime回傳133000。\n我們可以使用這個函數來判斷腳本的執行時間，例如在以下範例內使用CurrentTime來判斷腳本執行時是否已經是中午12:30分之後。\nBegin\n3 // 執行時間是中午12:30分以後\nEnd;

---

### SymbolType

**說明:**

一般函數\n回傳代碼 = SymbolType\n當回傳值為1時，表示商品是指數。\n當回傳值為2時，表示商品是股票。\n當回傳值為3時，表示商品是期貨。\n當回傳值為4時，表示商品是權證。\n當回傳值為5時，表示商品是選擇權。\n當回傳值為6時，表示商品是可轉債。\n當回傳值為7時，表示商品是特別股。

---

### SymbolExchange

**說明:**

一般函數\n回傳代碼 = SymbolExchange\n當回傳值為"TW"時，表示商品屬於台灣證券交易所（上市&上櫃）。\n當回傳值為"TE"時，表示商品屬於台灣興櫃。\n當回傳值為"TF"時，表示商品屬於台灣期貨交易所。\n當回傳值為"FS"時，表示商品屬於國際指數。\n當回傳值為"FX"時，表示商品屬於外匯。\n當回傳值為"HK"時，表示商品屬於香港交易所。\n當回傳值為"SH"時，表示商品屬於上海交易所。\n當回傳值為"SZ"時，表示商品屬於深圳交易所。\n當回傳值為"KS"時，表示商品屬於韓股。\n當回傳值為"JP"時，表示商品屬於日股。\n當回傳值為"US"時，表示商品屬於美股。\n當回傳值為"SG"時，表示商品屬於新加坡。

---

### SetTotalBar

SetTotalBar(資料讀取筆數)

**說明:**

一般函數\nSetTotalBar 用於設定腳本執行時，讀取的歷史K棒數量。\nSetTotalBar 設定的資料讀取筆數必須為非負整數。當腳本引用 SetTotalBar 並指定一個數值時，系統會預先提供指定數值的K棒，並從這些K棒的第一根 (編號為1) 開始執行腳本。\n不同腳本類型的規則：\n指標腳本： 將繪製的歷史 K 棒數量，不包含即時的 K 棒。\n選股腳本： 判斷目前K棒是否滿足選股條件之前，將執行的 K 棒數量。\n警示腳本： 開始接收即時價格更新並觸發警示訊號之前，將執行的 K 棒數量，不包含即時的 K 棒。\n自動交易腳本：(策略部位計算起點之前，或)開始接收即時價格更新並觸發警示訊號之前，將執行的 K 棒數量，不包含即時的 K 棒。\n如果在腳本中多次使用 SetTotalBar ，並設定了不同的數值：\n將會採用其中編譯成功的最大數值作為最終的K棒總數。\n若設定的數值不是非負整數，該行的SetTotalBar將被視為編譯失敗。\n如果在腳本中同時存在數個 SetTotalBar 和 SetFirstBarDate ，並設定了不同的數值時：\n系統將分別根據兩者被多次使用時的規則，決定接下來各自採用哪一個 SetTotalBar 與 SetFirstBarDate 做比較。\n接著採用兩者當中，最後一個成功完成編譯的函數設定。\n若其中一個函數因參數無效（例如 SetTotalBar 的資料讀取筆數為負數，或 SetFirstBarDate 的日期不合理）而編譯失敗，則只有另一個成功編譯的函數設定會被採用。

---

### SetTBMode

SetTBMode(繪圖模式)

**說明:**

一般函數\n支援模式的如下\nSetTBMode(1) 同v5.62行為，腳本資料計算筆數為資料讀取筆數加畫面上的K棒筆數，使用者拉動畫面會進行重算。\nSetTBMode(0) 預設值，腳本資料計算筆數為全部資料，整個數列只算一次，拉動畫面不會重算。

**範例:**

```xs
Input: Period(200, "EMA");
SetTBMode(1);//指定自定指標的繪圖模式，可以變更參數比較一下計算值的差異
Plot1(EMA(Close, Period), "EMA");
```

---

### SetPlotLabel

**說明:**

SetPlotLabel(繪圖序列編號，繪圖序列名稱)\n一般函數\n第一個參數是繪圖序列的編號，可以從1到99，\n第二個參數則是這個序列的名稱，為一個字串值\n這個函數可以用來指定這個繪圖序列的名稱，跟Plot函數的第二個參數是類似的。\n兩者最大的差異是，在Plot函數內的第二個參數目前只支援固定的字串，而SetPlotLabel的第二個參數則可以是一個字串相關的敘述式，使用上比較有彈性。\n舉例而言:\nInput: Period(10);\n2\n3\nPlot1(Average(Close, Period));\nSetPlotLabel(1, Text("天期(", NumToStr(Period, 0), ")"));\n在上述範例內我們希望指標圖形上面可以看到平均線的天期，例如如果天期是5的話，我們希望指標序列的名稱是"天期(5)"，而如果天期是10的話，則我們希望指標序列的名稱是"天期(10)"。\n由於天期是透過Input語法傳入的，數值可以動態被修改，沒有辦法寫成一個固定的字串，所以我們使用SetPlotLabel，搭配Text函數以及NumToStr函數來組出天期的字串。

---

### SetOutputName

SetOutputName(序號, 欄位標題)

**說明:**

一般函數\nSetOutputName1(欄位標題)\n預設的輸出欄位的標題為 "欄位"加上"序號"，例如"欄位1", "欄位2"等。為了讓輸出報表更清楚，可以使用SetOutputName指令來設定輸出欄位的名稱。\nSetOutputName必須傳入兩個參數:\n第一個參數是欄位的序號，從1到99，\n第二個參數是欄位的名稱\n例如:\nOutputField1(GetField("月營收年增率","M"));\nSetOutputName(1, "月營收年增率");\n在上面範例內指定第一個輸出欄位的標題為"月營收年增率"。\nSetOutputField指令也可以在函數名稱之後直接加上序號，例如SetOutputName1, SetOutputName2等。如果函數名稱內就包含序號的話，則就不需要傳入序號參數。\n上面的範例可以改寫成:\nOutputField1(GetField("月營收年增率","M"));\nSetOutputName1("月營收年增率");\n在XQ 5.60版之後，OutputField指令也增加了可以直接傳入欄位標題的功能。

---

### SetInputName

SetInputName(序號, 顯示名稱)

**說明:**

一般函數\nSetInputName1(顯示名稱)\nInput: Length(10);\n2\n3\nPlot1(Average(Close, Length));\n例如上面範例內定義了一個輸入參數，名稱為Length，初始值為10。在腳本內可以直接使用Length這個變數，而在腳本執行時則可以利用參數設定畫面來動態修改Length的數值，以便讓程式的設計更有彈性。\n如果希望在設定畫面上可以看到中文名稱，而不是英文的變數名稱的話，則可以使用SetInputName這個函數。\nInput: Length(10);\n2\n3\nSetInputName(1, "天期");\nPlot1(Average(Close, Length));\nSetInputName必須傳入兩個參數\n第一個參數是參數的序號，從1開始，\n第二個參數是參數的顯示名稱\n以下是指標設定的畫面，標示處內可以看到透過SetInputName所指定的參數的名稱\nSetInputField指令也可以在函數名稱之後直接加上序號，例如SetInputName1, SetInputName2等。如果函數名稱內就包含序號的話，則就不需要傳入序號參數。\n上面的範例可以改寫成:\nInput: Length(10);\n2\n3\nSetInputName1("天期");\nPlot1(Average(Close, Length));\n在XQ 5.60版之後，為了讓這個動作更簡單，使用者可以直接在Input語法內指定輸入參數的顯示名稱，上面的範例可以改寫成:\nInput: Length(10, "天期");\n2\n3\nPlot1(Average(Close, Length));\n新的Input的語法可以讓程式變的更短，而且由於顯示名稱跟Input可以寫在同一行內，使用者不需要再去記憶每個Input的序號，建議大家以後直接使用Input語法來指定輸入參數的顯示名稱。

---

### SetFirstBarDate

SetFirstBarDate(資料開始日期)

**說明:**

一般函數\nSetFirstBarDate 函數用於控制腳本執行時，所使用的第一個資料的日期，從而確定資料讀取的起始範圍。\n語法為 SetFirstBarDate(YYYYMMDD)，其中 YYYYMMDD 是起始日期的年、月、日，且必須為合理有效的日期。\n需要注意的是，SetFirstBarDate 不支援交易腳本。\n如果在腳本中多次使用 SetFirstBarDate 函數，並設定了不同的日期：\n將會採用其中最早（最小值）的日期作為最終的資料開始日期。\n若設定的日期不是合理有效的日期，該行的 SetFirstBarDate 將被視為編譯失敗。\n如果在腳本中同時存在數個 SetTotalBar 和 SetFirstBarDate，並設定了不同的數值時：\n系統將分別根據兩者被多次使用時的規則，決定接下來各自採用哪一個 SetTotalBar 與 SetFirstBarDate 做比較。\n接著採用兩者當中，最後一個成功完成編譯的函數設定。\n若其中一個函數因參數無效（例如 SetTotalBar 的資料讀取筆數為負數，或 SetFirstBarDate 的日期不合理）而編譯失敗，則只有另一個成功編譯的函數設定會被採用。

---

### SetBarMode

SetBarMode(函數計算方式)

**說明:**

一般函數\n對於Setbarmode 0,1,2 三種計算方式解釋:\nSetBarMode(0); //Auto，預設值\n由系統判定是simple函數 或是 series 函數\nSetBarMode(1); //指定為simple函數\nSimple型態是指，例如average 這類函數計算方式，今期所計算的平均數與前一期的平均數為個別獨立運用，不會相互有關係\n例如:平均數average\n(1,2,3,4,5)/5 = 3 ；(2,3,4,5,6)/5 = 4\n兩者計算的結果無關聯\nSetBarMode(2); //指定為series函數\nSeries 型態是指，例如MACD,RSI 指標，屬於連續性的數值，今期所計算的值會引用到前期的數值來做運算。\n例如RSI指標計算「期間內絕對漲幅」的公式為\nUP t = UP t-1 + 1 / N ( Ut – UP t-1) ，\n(N 為平滑平均天數， t 為當日值， t-1為前一日值)\n當期值t會使用到前期的(t-1) 進行運算

---

### SetBarFreq

**說明:**

SetBarFreq(支援頻率1, 支援頻率2, 支援頻率3, ...)\n一般函數\n可以傳入多個頻率字串\n頻率參數的格式如下\n日線: "D"，\n還原日線: "AD"，\n周線: "W"，\n還原周線: "AW"，\n月線: "M"，\n還原月線: "AM"，\n季線: "Q"，\n半年線: "H"，\n年線: "Y"

**範例:**

```xs
SetBarFreq("Q", "Y"); // 指定選股腳本只能執行在季線/年線的頻率上面
```

由於選股腳本內可能會同時運用到多種不同欄位的頻率，而不同頻率的欄位又有可能因為資料公佈的時間差而產生期別上的差異。為了幫助使用者選到合適的執行頻率，XS選股程式在執行時會先分析這個腳本內所使用到的所有欄位的頻率，然後列出可以挑選的頻率。如果使用者希望可以更精確的指定頻率的話，則可以使用SetBarFreq這個函數。

---

### SetBarBack

SetBarBack(最大引用筆數)

**說明:**

一般函數\nSetBarBack(最大引用筆數, "頻率")\n如果不傳頻率的話，則指定目前執行頻率的最大引用筆數。\n詳細介紹可以參考設置指定頻率引用筆數的應用。\n關於資料讀取範圍以及最大引用筆數的定義，請參考資料讀取範圍與腳本執行的關係。

---

### SetBackBar

SetBackBar(最大引用筆數)

**說明:**

一般函數\nSetBackBar(最大引用筆數, "頻率")\n如果不傳頻率的話，則指定目前執行頻率的最大引用筆數。\n詳細介紹可以參考設置指定頻率引用筆數的應用。\n關於資料讀取範圍以及最大引用筆數的定義，請參考資料讀取範圍與腳本執行的關係。

---

### SetAlign

SetAlign("籌碼",資料對位計算方式)

**說明:**

一般函數\nSetAlign("營收財報",資料對位計算方式)\n說明資料的對位定義\n無論是資料欄位或選股欄位，皆會在欄位可用頻率的K棒生成後，將對應時間的歷史資料標記在此根K棒上，舉例來說：\n資料欄位 "外盤量" 的可用頻率為分鐘、日、還原日，因此當GetField("外盤量",”10”)[n]時，可以想像在距離最新10分K之前的第n根10分K上，有一筆"外盤量"的資料標記在上面。\n至於最新K棒尚未結束之前，GetField("外盤量",”10”)[0]都會不斷被更新至最新10分K的標記當中。\n在對資料與K棒之間的標記關係，有了理解之後，就要來說明資料的對位方式，有以下兩種：\n1. 絕對對位：根據資料名義上的所屬期別來標記對位。\n例如 "大戶持股張數" 最快每周更新一次，那資料就會標記在當周的第一根K棒； "每股現金流量" 最快每季更新一次，那資料就會標記在當季的第一根K棒（標記更新後的持續區間，都會取得期初標記的資料，直到標記再次被更新為止）。\n2. 公布日對位：根據資料何時能被XS取得來標記對位（不一定等於資料被公司公布的時間，因為第一手資料公布後，上游的資料源會接收、整理後再轉給XQ，接著再轉成XS可以取得的格式）。\n例如 "每股現金流量" 第一季的資料在4/16首次可以被XS取得、第二季的資料在7/13首次可以被XS取得。那4/16會標記第一季的資料；7/13的K棒才會標記第二季的資料（4/16~7/12之間的K棒，會取得的是第一季的資料）。\nSetAlign的使用\n指標、警示、自動交易腳本的範例如下：\nSetAlign("籌碼", 0); //預設值，絕對對位\nSetAlign("營收財報", 0); //預設值，絕對對位\n3\n4\nSetAlign("籌碼", 1); //公布日對位\nSetAlign("營收財報", 1); //公布日對位\n選股腳本的範例如下，注意選股腳本的籌碼欄位不支援公布日對位：\nSetAlign("籌碼", 0); //預設值，絕對對位\nSetAlign("營收財報", 1); //預設值，公布日對位\n3\n4\nSetAlign("營收財報", 0); //絕對對位

---

### RaiseRunTimeError

RaiseRunTimeError(錯誤訊息)

**說明:**

一般函數\n舉例而言:\nif q_CurrentShareCapital < 100000000{100,000,000股*10 = 10億} then RaiseRunTimeError("市值小於10億踢除");\n上述是一個警示腳本，透過 q_CurrentShareCapital 欄位來判斷商品的股本是否小於10億，如果小於10億是的話則中斷執行。\n與下列程式比較:\nif q_CurrentShareCapital < 100000000{100,000,000股*10 = 10億} then return;\n請注意如果是使用return指令的話，則執行的這一筆bar雖然會被跳出，可是當還有新的K棒時，程式還是會繼續執行，如果判斷是否要跳出的邏輯比較複雜的話，可能會有一些效率上的影響。如果已經確定腳本不需要再執行的話，可以使用RaiseRuntimeError，比較有效率，而且執行的畫面上也可以看到錯誤訊息，方便使用者掌握腳本的狀態。

---

### Print

Print(數值1, 數值2, 數值3, ...)

**說明:**

一般函數\nPrint(指定檔案,數值1, 數值2, 數值3, ...) ← 交易腳本必須用此法才能列印到檔案。\n※執行選股與執行回測時，Print檔案加總超過 100M 就不會印出。

**範例:**

```xs
Print("Date=", NumToStr(Date, 0), "Close=", NumToStr(Close, 2));
Print(file("d:\print\"), "Date=", NumToStr(Date, 0), "Close=", NumToStr(Close, 2));
Print(file("[StrategyName]_[Symbol]_[StartTime].log"), "Date=", NumToStr(Date, 0), "Close=", NumToStr(Close, 2));
```

把上述指標腳本放入技術分析內，執行時可以在XSScript編輯器的執行畫面內看到輸出，每一筆bar寫出一筆紀錄
Print函數的執行結果除了在XSScript編輯器內可以看到之外，另外也會產生一個文字檔案。
檔案的輸出位置是在XQ安裝目錄底下的XS\Print子目錄內，檔案名稱預設為策略名稱加上商品名稱，檔名為**.log**。以上述為例輸出的檔案名稱為 C:\SysJust\XQ2005\XS\Print\Print範例\_2330.TW.log
策略名稱也就是代表雷達名稱、選股策略名稱、指標名稱或自動交易策略名稱。
使用者也可以利用File指令來指定輸出的目錄或是檔名，交易腳本必須用此法才能列印到檔案。
以下的範例會把輸出檔案寫在"d:\print"這個目錄內：
如果需要避開重覆Print在同一個檔案，可以運用File指令搭配[StartTime]參數，讓每次執行的Print檔案可以分開不同目錄，檔案維護上比較方便。
以下的範例會把輸出資料分開到不同檔案：
請參考File指令，以及教學文章。

---

### PlotLine

PlotLine(序列編號, x1, y1, x2, y2)

**說明:**

一般函數\nPlotLine(序列編號, x1, y1, x2, y2, "序列名稱")\n請參考：PlotLine語法的介紹 文章

---

### PlotK

PlotK(序列編號, vOpen, vHigh, vLow, vClose)

**說明:**

一般函數\nPlotK(序列編號, vOpen, vHigh, vLow, vClose, "序列名稱")\n序列名稱是非必需的參數，如果不傳的話，預設的序列名稱為"Plot"+序列編號，例如”Plot2”。\nvOpen, vHigh, vLow, vClose 對應的是K棒的開高低收。\n平均K線 (Heikin-Ashi) 範例：\nvar: ha_open(0), ha_high(0), ha_low(0), ha_close(0);\n2\n3\nif currentbar = 1 then\n5 ha_open = (open + close) / 2\nelse\n7 ha_open = (open[1] + close[1]) / 2;\n8\n9\nha_close = (open + high + low + close) / 4;\nha_high = maxlist(high, ha_open, ha_close);\nha_low = minlist(low, ha_open, ha_close);\n13\n14\nPlotK(1, ha_open, ha_high, ha_low, ha_close, "平均K線");

---

### PlotFill

PlotFill(序列編號, vFrom, vTo, "序列名稱");

**說明:**

一般函數\n第二個和第三個參數分別是當根 K 棒要填色的開始和結束點。 第四個參數是設定序列的名稱，為選填的參數。若沒有設定的話預設會是 " Plot "+序列編號。\n此函數能夠在線圖上指定區域填色的功能，例如 KD 指標的超買超賣區間，讓使用者能夠更簡單的辨識指標間的範圍。\n詳細說明可參考：如何運用函數繪製填色區塊 文章。

---

### Plot

Plot(輸出序號，指標數值)

**說明:**

一般函數\nPlot(輸出序號，指標數值，繪圖序列名稱)\nPlot(輸出序號，指標數值，繪圖序列名稱，checkbox:=1)\nPlot1(指標數值)\nPlot1(指標數值，繪圖序列名稱)\nPlot1(指標數值，繪圖序列名稱，checkbox:=1)\n每個指標腳本可以產生至多999個繪圖數列，實際使用時必須在Plot之後加上指定的繪圖序列編號，例如Plot1, Plot2, 到Plot999。\nPlot函數可以傳入三個參數\n第一個參數是指標的數值\n第二個參數是這個繪圖序列的名稱，可以不用傳。如果不傳的話，則繪圖序列的名稱為 "Plot"加上這個序列的編號\n第三個參數為「是否開啟下拉式選單」提供給使用者勾選顯示指標。可以不用傳，如果不傳的話，則不會有下拉式選單提供選擇。checkbox:=1 為預設顯示指標；checkbox:=0 為預設「不」顯示指標。

**範例:**

```xs
Plot1(Average(Close, 5));
Plot2(Close, "收盤價");
```

在範例#1 內輸出兩個繪圖數列，第一個數列為收盤價的五日平均值，圖形名稱為 "Plot1"，第二個數列為收盤價(Close)，圖形名稱為 "收盤價"。
Plot1到Plot99除了可以是一個函數之外，也可以在腳本內被當成數列來引用。

```xs
Plot1(Average(Close, 5));
Plot2(Close, "收盤價");
Value1 = Plot2 - Plot1;
Plot3(Value1, "差值");
```

在範例#2 內Value1的數值是繪圖數列2(Plot2)與繪圖數列1(Plot1)的相減值，然後把這個差值畫在Plot3上面。

```xs
plot1(open,"開盤價",checkbox:=0);
plot2(high,"最高價",checkbox:=0);
plot3(low,"最低價",checkbox:=0);
```

//checkbox:=1，為預設顯示指標。
2//checkbox:=0，為預設「不」顯示指標。
plot4(close,"收盤價",checkbox:=1);//預設繪製出「收盤價」指標
在範例#3 中，有使用到 checkbox 參數，故將此XS指標腳本加入指標後的技術分析副圖，在滑鼠點選下拉式選單圖示如下：

---

### Playsound

**說明:**

一般函數\n若同一次腳本運算中執行了複數個 PlaySound 函數，只會撥放最後執行的音訊檔案。\n在指定檔案時，若沒有指定絕對路徑的話，會從預設資料夾 C:\SysJust\XQ2005\User\Sound 搜尋符合的檔案。

**範例:**

```xs
PlaySound("GML.wav");
PlaySound("C:\SysJust\XQ2005\User\Sound\GML.wav");
```

---

### OutputField

OutputField(輸出序號, 數值)

**說明:**

一般函數\nOutputField(輸出序號, 數值, 小數位數)\nOutputField(輸出序號, 數值, 小數位數, 輸出欄位名稱)\nOutputField1(數值)\nOutputField1(數值, 小數位數)\nOutputField1(數值, 小數位數, 輸出欄位名稱)\nOutputField的語法可以傳入至多四個參數:\n第一個參數為輸出序號，從1到99，用來指定輸出欄位的順序\n第二個參數為要輸出的數值\n第三個參數指定輸出時數值的小數點位數，可以不傳\n從5.60版之後增加第四個參數，可以傳入輸出欄位的標題。如果不傳的話則預設的欄位標題為"欄位" + 序號。

**範例:**

```xs
OutputField(1, GetField("月營收年增率","M"));
OutputField(2, GetField("月營收月增率","M"), 1);
OutputField(3, GetField("月營收月增率","M"), 1, "月營收月增率");
OutputField1(GetField("月營收年增率","M"));
OutputField2(GetField("月營收月增率","M"), 1);
OutputField3(GetField("月營收月增率","M"), 1, "月營收月增率");
```

以上的範例在執行後會多產生三個欄位，第一個欄位為"欄位1"，內容為月營收年增率。第二個欄位為"欄位2"，內容為月營收年增率轉成一位小數點。第三個欄位為"月營收年增率"，內容與第二個欄位相同。
OutputField指令也可以在函數名稱之後直接加上序號，例如OutputField1, OutputField2等。如果函數名稱內就包含序號的話，則就不需要傳入序號參數。
上述的範例可以改寫為:
OutputField指令內所設定的欄位標題也可以透過SetOutputName函數來指定。
OutputField 也可以使用 order 來指定選股結果區的欄位數值上/下排序，請參考連結說明使用。

---

### NoPlot

NoPlot(指標繪圖序列編號)

**說明:**

一般函數\n指標繪圖序列編號從1到999\n如果在某些情形底下我們希望某個序列這一點的值不要畫的話，則可以使用NoPlot的語法來做清除的動作。\n以下我們先看一個範例:\nValue1 = Close - Close[1];\nPlot1(Value1);\n在上面這個腳本內，我們先計算先後兩筆K棒的差值，然後把差值畫在Plot1上面。\n如果我們希望只有上漲時才畫的話，那則可以改成這樣子的寫法:\nValue1 = Close - Close[1];\nPlot1(Value1);\nIf Value1 <= 0 Then NoPlot(1);\n上述範例內使用NoPlot函數，指定序列1在Value1 <= 0 的時候不要畫圖。

---

### MaxBarsBack

```xs
Value1 = MaxBarsBack
```

**說明:**

一般函數\n關於資料讀取範圍以及最大引用筆數的定義，請參考資料讀取範圍與腳本執行的關係。

---

### IsSessionLastBar

**說明:**

一般函數\n回傳布林值=IsSessionLastBar

---

### IsSessionFirstBar

**說明:**

一般函數\n回傳布林值=IsSessionFirstBar

---

### IsLastBar

**說明:**

一般函數\n回傳布林值=IsLastBar

---

### IsFirstCall

**說明:**

一般函數\n傳入事件字串：" "、"Bar"、"Date"、"Realtime"、"RealBar"\n回傳布林值=IsFirstCall\nisfirstcall("Bar")：此根 Bar 的第一次洗價\nisfirstcall("Date")：此交易日的第一次洗價\nisfirstcall("Realtime")：此交易日進入即時洗價區間的第一次洗價\nisfirstcall("RealBar")：此交易日進入即時洗價區間，首次產生成交事件後的第一次洗價(通常會與"Realtime"一致；若是在揭示未成交K棒時，遇到暫緩開盤或開盤後沒有成交事件，兩者就會產生差異)\n詳細說明與範例請參考：\nhttps://www.xq.com.tw/learn/xspractice/isfirstcall/

---

### GetTotalBar

**說明:**

一般函數\n回傳數值= GetTotalBar\n關於執行筆數以及最大引用筆數的說明，請參考資料讀取範圍與腳本執行的關係。

---

### GetTBMode

**說明:**

一般函數\n回傳數值= GetTBMode\n回傳數值如下\nSetTBMode(1) 同v5.62行為，腳本資料計算筆數為資料讀取筆數加畫面上的K棒筆數，使用者拉動畫面會進行重算。\nSetTBMode(0) 預設值，腳本資料計算筆數為全部資料，整個數列只算一次，拉動畫面不會重算。

**範例:**

```xs
Input: Period(200, "EMA");
Input: TB(1);
Plot1(EMA(Close, Period), "EMA");
Plot2(GetTBMode);//取得自定指標的繪圖模式
```

SetTBMode(TB);//指定自定指標的繪圖模式，可以變更參數比較一下計算值的差異

---

### GetSymbolFieldStartOffset

欄位筆數 = GetSymbolFieldStartOffset("ID", "欄位名稱")

**說明:**

一般函數\n欄位筆數 = GetSymbolFieldStartOffset("ID", "欄位名稱","頻率")\n回傳目前最新一筆欄位與此欄位的第一筆資料間的欄位筆數。\n如果無此欄位，或是欄位的初始點超過目前bar的位置，則回-1。\n※如果不傳頻率的話，則讀取目前執行頻率的對應欄位。\n※僅支援「選股」腳本類型。\n以下是一個簡單的範例：\nValue1 = GetSymbolFieldStartOffset("1101.TW", "月營收");　// value1 為取得目前腳本執行頻率的台泥(1101)目前最新一筆月營收欄位與月營收欄位第一筆資料間的欄位筆數。\nValue2 = GetSymbolFieldStartOffset("1101.TW", "月營收", "M");　// value2 為取得月頻率的台泥(1101)目前最新一筆月營收欄位與月營收欄位第一筆資料間的欄位筆數。\n詳細的語法說明可以參考 GetFieldStartOffset函數。

---

### GetInfo

回傳數值=GetInfo(資訊名稱)

**說明:**

一般函數\n傳入一個參數:\n- 第一個參數是資訊名稱字串，可以是"Instance"、"IsRealTime"、"IsTimerMode"、"FilterMode"、"TradeMode"、"AT_EnableTrade"、"AT_BID"、"AT_AccType"或"AT_AID"\n當參數為"Instance"時，可以取得腳本執行的功能：\n回傳值為1表示自訂指標。\n回傳值為2表示策略雷達。\n回傳值為3表示XS選股。\n回傳值為31表示XS選股自訂排行。\n回傳值為4表示策略雷達回測（進場）。\n回傳值為41表示策略雷達回測（出場）。\n回傳值為5表示自動交易\n回傳值為6表示自動交易回測\n當參數為"IsRealTime"時，可以取得K棒的狀態：\n回傳值為0表示該筆資料為歷史資料或其他。\n回傳值為1表示該筆資料為即時成交更新資料，需注意當該筆運算是因為自動洗價觸發時，就算資料不是即時成交更新也會回傳1。\n當參數為"IsTimerMode"時，可以判斷該次洗價是否因為自動洗價所觸發，只支援警示腳本和交易腳本：\n回傳值為1表示該次洗價是因為自動洗價所導致。\n回傳值為0表示為成交洗價觸發，或是使用在其他腳本上。\n當參數為"FilterMode"時，可以取得XS選股的模式：\n回傳值為1表示XS選股。\n回傳值為2表示XS選股回溯。\n回傳值為3表示XS選股回測（進場）。\n當參數為"TradeMode"時，可以交易策略目前執行的K棒是否處於資料讀取區間：\n回傳值為0表示目前執行的K棒處理資料讀取區間，所以交易指令不會執行。\n回傳值為1表示目前執行的K棒處理策略部位計算區間或是即時區間，交易指令將會執行。\n當參數為"AT_EnableTrade"時，可以取得目前交易策略是否有啟動帳號：\n回傳值為0表示回測或即時區間但沒有設定交易帳號。\n回傳值為1表示即時區間且有設定交易帳號。\n當參數為"AT_BID"時，可以取得券商的字串代碼：\n回傳值為空白字串表示策略沒有設定交易帳號或是在回測。\n回傳值為SYSTRADE表示策略帳號為模擬交易帳號。\n回傳值為SYSCAMPUS表示策略帳號為校園模擬競賽。\n其他券商會回傳各自對應的代碼。\n當參數為"AT_AccType"時，可以取得策略運作的業務類別:\n回傳值為1表示業務類別為證券。\n回傳值為2表示業務類別為期貨。\n回傳值為3表示業務類別為複委託。\n回傳值為0表示策略沒有設定交易帳號或是在回測。\n當參數為"AT_AID"時，可以取得目前策略運作的帳號:\n回傳值為空白字串表示策略沒有設定交易帳號或是在回測。\n回傳值為券商代碼加上交易帳號組成的字串。\n關於AT的EnableTrade、BID、AccType以及AID的進一步說明，可以參考自動交易語法 取得「交易帳號」使用說明

**範例:**

```xs
value1 = getinfo("IsRealTime"); //若value1為1，則代表目前計算的是即時資料
plot1(value1);
```

---

### GetFirstBarDate

**說明:**

一般函數\n回傳日期= GetFirstBarDate\n日期格式是一個8碼的數字，如果第一筆資料日期是是2009年1月2日，則回傳20090102\n關於資料讀取範圍的定義，請參考資料讀取範圍與腳本執行的關係。

---

### GetFieldStartOffset

欄位筆數 = GetFieldStartOffset("欄位名稱")

**說明:**

一般函數\n欄位筆數 = GetFieldStartOffset("欄位名稱", "頻率")\n回傳目前最新一筆欄位與此欄位的第一筆資料間的欄位筆數。\n如果無此欄位，或是欄位的初始點超過目前bar的位置，則回-1。\n※如果不傳頻率的話，則讀取目前執行頻率的對應欄位。\n※僅支援「選股」腳本類型。\n例如目前可能是跑日線，然後GetFieldStartOffset要查的是月頻率欄位，此時 GetFieldStartOffset所回傳的是月頻率欄位有幾筆。\n選股腳本範例：判斷當月營收是否創掛牌新高\nvalue1 = GetFieldStartOffset("月營收", "M");\nif value1 = 0 then begin\n3 ret = 1; // 只有1期, 就當成創新高了吧\n4 outputField1(GetField("月營收", "M"),"月營收");\nend else if value1 > 0 then begin\n6 // 算出前N期的最大值\n7 value2 = Highest(GetField("月營收", "M")[1], value1);\n8 if GetField("月營收", "M") > value2 then ret = 1;\n9 outputField1(GetField("月營收", "M"),"月營收");\nend;\n範例選股範例：判斷創N期新高\ninput: min_period(12, "最低期別");\nvalue1 = GetFieldStartOffset("月營收", "M");\nvalue2 = GetField("月營收", "M");// 最新一期營收\nvar: idx(0);\nidx = 1;\nwhile idx <= value1 begin\n7 if GetField("月營收", "M")[idx] < value2 then\n8 idx = idx + 1\n9 else\n10 break;\nend;\nif idx >= min_period then begin\n13 ret=1;\n14 OutputField(1, idx, 0, "創新高期別");\n15 OutputField(2, GetField("月營收", "M")[idx], "創新高的月營收");\n16 OutputField(3, GetFielddate("月營收", "M")[idx], 0, "創新高的月營收資料日期");\nend;

---

### GetBarOffset

回傳數值=GetBarOffset(日期)

**說明:**

一般函數\n回傳數值=GetBarOffset(日期，時間)\n傳入二個參數：\n- 第一個參數是交易日的日期，格式為YYYYMMDD。\n- 第二個參數是時間，格式為HHMMSS，第二個參數可以不用傳。\n可以傳入兩個參數：\n第一個參數是日期，格式為YYYYMMDD。\n第二個參數是時間，格式為HHMMSS，第二個參數可以不用傳。\n當回傳值為0時，表示傳入日期/時間 ≧K棒日期/時間。\n當回傳值為1時，代表目前K棒的前一根K棒日期/時間為傳入日期/時間。

**範例:**

```xs
value1 = GetBarOffset(20150831); //取得20150831這根K棒的相對位置
```

注意，當無傳入日期這根K棒時，會往前找到最接近的一根。例如：20150829、20150830是非交易日，所以會往前找到20150828這根K棒。也就是說GetBarOffset(20150828)、GetBarOffset(20150829)、GetBarOffset(20150830)的回傳值會是相等的。
value2 = High[value1]; //取得20150831當天的最高價
plot1(value2); //繪出20150831最高價的水平線

---

### GetBarBack

**說明:**

一般函數\n回傳數值= GetBarBack\n關於資料讀取範圍以及最大引用筆數的定義，請參考資料讀取範圍與腳本執行的關係。

---

### GetBackBar

**說明:**

一般函數\n回傳數值= GetBackBar\n關於資料讀取範圍以及最大引用筆數的定義，請參考資料讀取範圍與腳本執行的關係。

---

### File

**說明:**

Print(File(檔案路徑), 輸出數值1, 輸出數值2, 輸出數值3)\n一般函數\nPrint(File(檔案名稱), 輸出數值1, 輸出數值2, 輸出數值3)\n如果使用者希望指定不同的輸出目錄，或是不同的輸出檔案名稱的話，則可以使用File指令來做設定。\nFile指令有兩種用法:\n第一種用法是傳入目錄名稱，例如File("d:\Print")，請注意路徑名稱的結尾必須是""。一旦指定目錄之後，所有的Print輸出檔案都會產生在這個目錄底下，輸出檔案名稱還是策略名稱\_商品代碼.log，\n第二種用法是傳入檔案名稱，例如File("d:\Print\MyOutput.log")。一旦指定檔案名稱之後，所有Print的輸出都會寫到這個檔案內，包含所有被執行到的商品。

**範例:**

```xs
Print(File("d:\Print\"), date,symbol,close);
Print(File("d:\Print\MyOutput.log"), date,symbol,close);
Print(File("d:\Print\[Date]_[ScriptName]_[Symbol]_[Freq].log"), date, symbol, close);
Print(file("[StrategyName]_[Symbol]_[StartTime].log"), "Date=", NumToStr(Date, 0), "Close=", NumToStr(Close, 2));
```

除了以上用法之外，File內的檔案名稱或是目錄名稱也可以包含以下的特殊字串:
[StrategyName] ← 轉換成策略名稱，也就是代表雷達名稱、選股策略名稱、指標名稱、自動交易策略名稱
[StartTime] ← 轉換成策略的啟動時間，格式為HHMMSS
[Symbol] ← 轉換成執行的商品代碼
[Freq] ← 轉換成執行的頻率
[ScriptName] ← 轉換成腳本名稱
[Date] ← 轉換成YYYYMMDD的日期
如果檔案名稱或是目錄名稱包含以上的特殊字串的話，則XS會把這些字串轉換成執行的商品，頻率，腳本名稱後組成輸出的目錄名稱或是檔案名稱。
舉例而言:
如果腳本名稱是"MyScript", 執行的頻率是日, 執行的商品為2330.TW的話，則Print指令所產生的檔案會是"d:\Print\MyScript_2330.TW_D.log"。請注意如果檔案名稱內有包含特殊字串的話，則每個商品的Print檔案會獨立產生，而不是寫到同一個檔案內。
如果需要避開重覆Print在同一個檔案，可以運用File指令搭配[StartTime]參數，讓每次執行的Print檔案可以分開不同目錄，檔案維護上比較方便。
以下的範例會把輸出資料分開到不同檔案：
請參考File指令，以及教學文章。

---

### ExecOffset

```xs
Value1 = Average(Volume, 5);
```

**說明:**

一般函數\n偏移筆數 = ExecOffset\n一般的函數呼叫方式如下:\n此時如果從Average函數內去呼叫ExecOffset時得到的值是0。\n如果呼叫的方式改成:\nValue1 = Average(Volume, 5)[1];\n的話，則在呼叫Average函數時利用**[1]**設定了偏移的K棒個數，此時Average function執行時取得的資料是當時資料往前偏移一筆的結果，也就是說Value1會是前5日成交量的平均值，不包含最新一日的成交量。\n在這樣子的使用情境底下，Average函數內讀取ExecOffset時會得到1.

---

### DataAlign

DataAlign(欲設定的資料對位方式)

**說明:**

一般函數\n如果是絕對對位的話，資料對位方式為0，如果是遞補對位的話，資料對位方式為1\n以下的圖示內我們使用日線頻率的外資買賣超資料來說明資料對位的處理邏輯。\n由於每日外資買賣超資料都是在下午16:00以後才會公布，也就是在當日交易區段時價位資料的日期與外資買賣超資料的日期會有一天的差異。所以當以下的腳本在5/28日上午執行時\nif Close > Close[1] and\n2 GetField("外資買賣超") > 0 then ...\n系統會依照對位方式決定GetField("外資買賣超")函數會取得哪一天的外資買賣超資料。\n目前系統支援兩種資料對位方式，分別是\n絕對對位\nDataAlign(0);\n遞補對位\nDataAlign(1);\n在絕對對位模式時，GetField("外資買賣超")函數的日期必須與價位日期一致(同期別)，也就是說系統會嘗試讀取5/28日的外資買賣超資料，此時由於資料尚未公佈，所以執行會發生失敗(引用資料不存在)。\n而在遞補對位模式時，系統在找不到5/28日的外資買賣超資料時，會自動往前尋找。在上面的範例內 GetField("外資買賣超")則會找到5/27日的外資買賣超資料。\n目前系統預設的資料對位方式依照腳本類型而有所不同:\n如果是指標腳本或是雷達腳本，資料對位方式預設為絕對對位 (DataAlign(0))\n如果是選股腳本，資料對位方式預設為遞補對位 (DataAlign(1))\n選股腳本由於常常需要讀取營收/財報等欄位資料，而這些資料通常公佈時間都是落後於價位日期的，所以預設為遞補對位。\n使用者如果知道所需資料的日期的話，也可以透過不同的寫法來讀取到預期的資料，不需要更改對位模式。以上述範例而言，如果這是一個策略雷達腳本的話，由於策略雷達腳本的執行時間通常是在交易時間區段，此時外資買賣超資料一定會落後一期。所以腳本可以修改成下列寫法:\nif Close > Close[1] and\n2 GetField("外資買賣超")[1] > 0 then ...\n注意到腳本內使用**GetField("外資買賣超")[1]**語法來讀取前一期的外資買賣超。

---

### CurrentBar

```xs
value1 = Close
```

**說明:**

一般函數\nK棒編號 = CurrentBar\n可以使用這個函數來判斷目前腳本執行的時機點\nif CurrentBar = 1 then\nelse\n4 value1 = value1[1] + value2 \* (Close - value1[1]);\n上述範例利用CurrentBar來判斷目前是否是第一筆K棒。如果是的話則回傳XAverage的初始數值。

---

### CallFunction

**說明:**

回傳數值=CallFunction(函數名稱,參數一,參數二,...)\n一般函數\n傳入一個以上參數:\n- 第一個參數是函數名稱的字串。\n- 第二個參數是被呼叫函數的第一個參數。\n- 第三個參數是被呼叫函數的第二個參數。依此類推。\nCallFunction的用法很簡單，第一個參數固定是要被呼叫的函數名稱，其餘的參數就是看被呼叫函數需要幾個參數，依序填入即可。

**範例:**

```xs
plot1(average(c,5));
plot2(callfunction("average",c,5));
```

3//以上二個寫法效果是一樣的

---

### BarInterval

```xs
If BarFreq = "Min" Then
```

**說明:**

一般函數\n分鐘區間 = BarInterval\n如果頻率是分鐘資料，則回傳分鐘的間隔，例如30分鐘線的話則回傳30，否則一律回傳1\n// 先判斷目前是分鐘線\nBegin\n4 If BarInterval = 30 Then\n5 Begin\n6 // 資料為30分鐘線\n7 End;\nEnd;

---

### BarFreq

**說明:**

一般函數\n執行頻率 = BarFreq\n回傳以下字串: 分鐘線:"Min",\n日線:"D",周線:"W", 月線:"M",\n還原日線:"AD",還原周線:"AW", 還原月線:"AM",\n季線:"Q", 半年線:"H",年線:"Y"\n//確認資料必須是日線\nif BarFreq <> "D" then return;

---

### BarAdjusted

```xs
if BarFreq <> "D" or BarAdjusted <> True  then raiseRunTimeError("僅支援還原日頻率");
```

**說明:**

一般函數\n若為還原頻率，則回傳「True」\n若不為還原頻率，則回傳「False」\n在執行頻率為「分鐘」的資料表達為：\n如果資料頻率是還原5分鐘，則 BarInterval = 5，BarFreq = "Min"，BarBarAdjusted = true。\n如果資料頻率是5分鐘，則 BarInterval = 5，BarFreq = "Min"，BarBarAdjusted = false。\n在執行頻率為「日」以上頻率的資料表達為：\n如果資料是還原日線, 則 BarFreq = "AD", BarAdjusted = true。\n如果資料是日線, 則BarFreq = "D", BarAdjusted = false。\n應用在指定策略執行的頻率，避免執行頻率設定錯誤的範例語法如下：\n範例一：確認執行頻率必須是「還原日」頻率才可執行\n範例二：確認執行頻率必須是「還原5分鐘」頻率才可執行\nif BarInterval <> 5\nor barFreq <> "Min"\nor BarAdjusted <> true then raiseRunTimeError("僅支援還原5分鐘線圖");

---
